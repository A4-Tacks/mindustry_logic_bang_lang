// this is a lalrpop file
#![allow(clippy::just_underscores_and_digits)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::deprecated_cfg_attr)]

use crate::syntax::{
    Errors,
    Error,
    Op,
    Value,
    Var,
    DExp,
    JumpCmp,
    Goto,
    Expand,
    Select,
    Const,
    Take,
    LogicLine,
    Meta,
};

grammar(meta: &mut Meta);

extern {
    type Error = Error;
    type Location = Location;
}

match {
    r"\s+" => {}, // empty
    r##"#(?:[\r\n]|[^\*][^\r\n]*)"## => {}, // inline comments
    r##"#\*[^*]*\*+(?:[^#*][^*]*\*+)*#"## => {}, // long comments
} else {
    _
}

pub String: Var = r#""[^"]*""# => <>.replace('\n', "\\n");
pub Ident: Var = r"[_\p{XID_Start}]\p{XID_Continue}*" => <>.into();
pub OIdent: Var = r"@[_\p{XID_Start}][\p{XID_Continue}\-]*" => <>.into(); // `@abc-def`这种
pub Number: Var = r"(?:0(?:x-?[\da-fA-F][_\da-fA-F]*|b-?[01][_01]*)|-?\d[_\d]*(?:\.\d[\d_]*)?)"
    => <>.chars().filter(|&c| c != '_').collect();
pub OtherValue: Var = r"'[^'\s]+'" => {
    let mut res: Var = <>.chars().skip(1).collect();
    res.pop().unwrap();
    res
}; // 特殊格式的值, 如`'@abc-def'`

// 逻辑里面一个单元
// 例如`0x50` `'@alpha'` `add` `'a-b-c'`
pub Var: Var = {
    String,
    Ident,
    OIdent,
    Number,
    OtherValue,
}

pub Value: Value = {
    Var => <>.into(),
    DExp => <>.into(),
    "$" => Value::ResultHandle,
}

pub LiteralUInt: usize = <l:@L> <num:Number> <r:@R> =>? {
    let mut chars = num.chars();
    let res = if let Some('0') = chars.next() {
        match chars.next() {
            Some('x') => usize::from_str_radix(&chars.collect::<String>(), 16),
            Some('b') => usize::from_str_radix(&chars.collect::<String>(), 2),
            _ => num.parse::<usize>(),
        }
    } else {
        num.parse::<usize>()
    };
    match res {
        Ok(num) => Ok(num),
        Err(e) => Err(Error::from(([l, r], Errors::NotALiteralUInteger(num, e))).into()),
    }
};


Or<A, B> = { A, B }; // A或者B
Or3<A, B, C> = { A, B, C }; // A或者B或者C
OrSwap<A, B> = { A B, B A }; // 匹配 `A B`或者`B A`
OrRev<A, M, B> = { A M B, B, M, A }; // 匹配`A M B`或者`B M A`
OrShl<A, B, C> = { A B C, B C A }; // 匹配`A B C`或者`B C A`, 后者是值进行左移循环得到
Wrap<Open, T, Close> = Open <T> Close; // 用于定义包裹
MTuple<T> = Wrap<"(", T, ")">;
MList<T> = Wrap<"[", T, "]">;
MBlock<T> = Wrap<"{", T, "}">;
OpenArgs<T, S> = (<T> S)*; // 零至多个有分隔后缀值
CloseArgs<T, S> = (<T> S)* T => { // 一至多个有分隔无后缀值
    let (mut args, tail) = <>;
    args.push(tail);
    args
};
Span<T> = @L T @R;

LEnd: () = ";" => ();

pub JumpCmp: JumpCmp = {
    <OrSwap<Or<"equal", "==">, <Value>>> <Value> => JumpCmp::Equal(<>),
    <OrSwap<Or<"notEqual", "!=">, <Value>>> <Value> => JumpCmp::NotEqual(<>),
    <OrSwap<Or<"lessThan", "<">, <Value>>> <Value> => JumpCmp::LessThan(<>),
    <OrSwap<Or<"lessThanEq", "<=">, <Value>>> <Value> => JumpCmp::LessThanEq(<>),
    <OrSwap<Or<"greaterThan", ">">, <Value>>> <Value> => JumpCmp::GreaterThan(<>),
    <OrSwap<Or<"greaterThanEq", ">=">, <Value>>> <Value> => JumpCmp::GreaterThanEq(<>),
    <OrSwap<Or<"strictEqual", "===">, <Value>>> <Value> => JumpCmp::StrictEqual(<>),
    Or<"always", "_"> => JumpCmp::Always,
    // 扩展
    Or<"lnot", "!"> <Value> => JumpCmp::bool(<>).reverse(),
    <Value> => JumpCmp::bool(<>),
}

pub Op: Op = {
    // 2
    <a:OrShl<Or<"add", "+">, <Value>, <Value>>> <b:Value> => Op::Add(a.0, a.1, b),
    <a:OrShl<Or<"sub", "-">, <Value>, <Value>>> <b:Value> => Op::Sub(a.0, a.1, b),
    <a:OrShl<Or<"mul", "*">, <Value>, <Value>>> <b:Value> => Op::Mul(a.0, a.1, b),
    <a:OrShl<Or<"div", "/">, <Value>, <Value>>> <b:Value> => Op::Div(a.0, a.1, b),
    <a:OrShl<Or<"idiv", "//">, <Value>, <Value>>> <b:Value> => Op::Idiv(a.0, a.1, b),
    <a:OrShl<Or<"mod", "%">, <Value>, <Value>>> <b:Value> => Op::Mod(a.0, a.1, b),
    <a:OrShl<Or<"pow", "**">, <Value>, <Value>>> <b:Value> => Op::Pow(a.0, a.1, b),
    <a:OrShl<Or<"equal", "==">, <Value>, <Value>>> <b:Value> => Op::Equal(a.0, a.1, b),
    <a:OrShl<Or<"notEqual", "!=">, <Value>, <Value>>> <b:Value> => Op::NotEqual(a.0, a.1, b),
    <a:OrShl<Or<"land", "&&">, <Value>, <Value>>> <b:Value> => Op::Land(a.0, a.1, b),
    <a:OrShl<Or<"lessThan", "<">, <Value>, <Value>>> <b:Value> => Op::LessThan(a.0, a.1, b),
    <a:OrShl<Or<"lessThanEq", "<=">, <Value>, <Value>>> <b:Value> => Op::LessThanEq(a.0, a.1, b),
    <a:OrShl<Or<"greaterThan", ">">, <Value>, <Value>>> <b:Value> => Op::GreaterThan(a.0, a.1, b),
    <a:OrShl<Or<"greaterThanEq", ">=">, <Value>, <Value>>> <b:Value> => Op::GreaterThanEq(a.0, a.1, b),
    <a:OrShl<Or<"strictEqual", "===">, <Value>, <Value>>> <b:Value> => Op::StrictEqual(a.0, a.1, b),
    <a:OrShl<Or<"shl", "<<">, <Value>, <Value>>> <b:Value> => Op::Shl(a.0, a.1, b),
    <a:OrShl<Or<"shr", ">>">, <Value>, <Value>>> <b:Value> => Op::Shr(a.0, a.1, b),
    <a:OrShl<Or<"or", "|">, <Value>, <Value>>> <b:Value> => Op::Or(a.0, a.1, b),
    <a:OrShl<Or<"and", "&">, <Value>, <Value>>> <b:Value> => Op::And(a.0, a.1, b),
    <a:OrShl<Or<"xor", "^">, <Value>, <Value>>> <b:Value> => Op::Xor(a.0, a.1, b),

    <OrSwap<"max", <Value>>> <Value> <Value> => Op::Max(<>),
    <OrSwap<"min", <Value>>> <Value> <Value> => Op::Min(<>),
    <OrSwap<"angle", <Value>>> <Value> <Value> => Op::Angle(<>),
    <OrSwap<"len", <Value>>> <Value> <Value> => Op::Len(<>),
    <OrSwap<"noise", <Value>>> <Value> <Value> => Op::Noise(<>),

    // 1
    // 此处使用`Value`来接受逻辑导出时的占位符
    <OrSwap<Or<"not", "~">, <Value>>> <Value> Value? => Op::Not(<>),
    <OrSwap<"abs", <Value>>> <Value> Value? => Op::Abs(<>),
    <OrSwap<"log", <Value>>> <Value> Value? => Op::Log(<>),
    <OrSwap<"log10", <Value>>> <Value> Value? => Op::Log10(<>),
    <OrSwap<"floor", <Value>>> <Value> Value? => Op::Floor(<>),
    <OrSwap<"ceil", <Value>>> <Value> Value? => Op::Ceil(<>),
    <OrSwap<"sqrt", <Value>>> <Value> Value? => Op::Sqrt(<>),
    <OrSwap<"rand", <Value>>> <Value> Value? => Op::Rand(<>),
    <OrSwap<"sin", <Value>>> <Value> Value? => Op::Sin(<>),
    <OrSwap<"cos", <Value>>> <Value> Value? => Op::Cos(<>),
    <OrSwap<"tan", <Value>>> <Value> Value? => Op::Tan(<>),
    <OrSwap<"asin", <Value>>> <Value> Value? => Op::Asin(<>),
    <OrSwap<"acos", <Value>>> <Value> Value? => Op::Acos(<>),
    <OrSwap<"atan", <Value>>> <Value> Value? => Op::Atan(<>),
    // 扩展(1)
    <OrSwap<Or<"lnot", "!">, <Value>>> <Value> Value? => Op::Equal(<>, "false".into()),
}

Label: String = ":" <Var>;

pub Expand: Expand = LogicLine* => Expand(<>);
pub LogicLine: LogicLine = {
    Control,
    BuiltinCommand,
    MBlock<Expand> => <>.into(),
    Label => LogicLine::Label(<>),
    "op" <Op> LEnd => <>.into(),
    "noop" LEnd => LogicLine::NoOp,
    "end" LEnd => LogicLine::End,
    "set" <var:Value> <value:Value> LEnd => LogicLine::Other(vec!["set".into(), var.into(), value]),
    <var:Value> "=" <value:Value> LEnd => LogicLine::Other(vec!["set".into(), var.into(), value]),
    "read" <var:Value> <from:Value> <index:Value> LEnd
        => LogicLine::Other(vec!["read".into(), var.into(), from, index]),
    "print" <Args> LEnd => {
        if <>.is_empty() {
            // 无参数, 啥也不做
            return LogicLine::Ignore
        }
        if <>.len() == 1 {
            // 单个参数, 老式处理
            return LogicLine::Other(vec!["print".into(), <>.into_iter().next().unwrap()])
        }
        Expand(
            <>.into_iter()
                .map(|arg| LogicLine::Other(vec!["print".into(), arg]))
                .collect()
        ).into()
    },
    <cmd:Value> <mut args:Args> LEnd => {
        args.insert(0, cmd);
        LogicLine::Other(args)
    },
}

#[inline] Args: Vec<Value> = {
    () => vec![],
    Value => vec![<>],
    Value Value => vec![<>],
    Value Value Value => vec![<>],
    Value Value Value Value => vec![<>],
    Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value Value Value Value => vec![<>],
}

pub BuiltinCommand: LogicLine = {
    "const" <Var> "=" <Value> LEnd => Const(<>).into(),

    // 如果后方是一个Var则直接将常量映射到后方的值
    // 如果后方是一个DExp则将其计算然后将常量映射到计算出的句柄
    // 此处默认句柄使用Value
    "take" <Var> "=" <Value> LEnd => Take(<>).into(),
}

//  if结构定义
//  ```
//  if x {
//      1
//  } elif y {
//      2
//  } elif z {
//      3
//  } else {
//      4
//  }
//  ```
//
//  被转换为
//  ```
//  goto :a x
//  goto :b y
//  goto :c z
//  4
//  goto :d _
//  :b
//  2
//  goto :d _
//  :c
//  3
//  goto :d _
//  :a
//  1
//  :d
//  ```
//
//  goto :a x
//  $($elif_gotos)*
//  $else_body?
//  goto :end _
//  $(
//      $elif_tag
//      $elif_body
//      goto :end _
//  )*
//  :a
//  $if_body
//  :end

pub Block: LogicLine = MBlock<Expand> => <>.into();

pub DExp: DExp = MTuple<(<(<Var> ":")?> <Expand>)>
    => DExp::new(<>.0.unwrap_or_default(), <>.1);

pub Control: LogicLine = {
    "goto" <Label> <JumpCmp> LEnd => Goto(<>).into(),

    "skip" <cmp:JumpCmp> <body:LogicLine> => {
        let lab = meta.get_tag();
        Expand(vec![
            Goto(lab.clone(), cmp).into(),
            body,
            LogicLine::Label(lab),
        ]).into()
    },

    "while" <cmp:JumpCmp> <body:LogicLine> => {
        let [end, head] = [meta.get_tag(), meta.get_tag()];
        let rev_cmp = cmp.clone().reverse();
        Expand(vec![
            Goto(end.clone(), rev_cmp).into(),
            LogicLine::Label(head.clone()),
            body,
            Goto(head, cmp).into(),
            LogicLine::Label(end),
        ]).into()
    },

    "do" <body:Block> "while" <cmp:JumpCmp> LEnd => {
        let head = meta.get_tag();
        Expand(vec![
            LogicLine::Label(head.clone()),
            body,
            Goto(head, cmp).into(),
        ]).into()
    },

    "switch" <value:Value>
    <cases:MBlock<("case" <LiteralUInt+> ":" <Expand>)+>>
    => {
        let case_num_max = cases
            .iter()
            .map(
                |(nums, _)| *nums
                    .iter()
                    .max()
                    .unwrap()
            )
            .max()
            .unwrap();
        let mut cases_res = Vec::with_capacity(case_num_max);
        for (nums, expand) in cases {
            for num in nums {
                for _ in cases_res.len()..=num {
                    cases_res.push(LogicLine::NoOp)
                }
                cases_res[num] = expand.clone().into()
            }
        }
        debug_assert_eq!(cases_res.len(), case_num_max + 1);
        Select(value, Expand(cases_res)).into()
    },

    "if" <cmp:JumpCmp> <body:Block>
        <elifs:("elif" <JumpCmp> <Block>)*>
        <else_body:("else" <LogicLine>)?> => {

        let end = meta.get_tag();
        let true_start = meta.get_tag();
        let mut elif_tags = Vec::with_capacity(elifs.len());
        elif_tags.extend((0..elifs.len()).map(|_| meta.get_tag())); // build elif tags
        let (mut elif_cmps, mut elif_bodys) = (
            Vec::with_capacity(elifs.len()),
            Vec::with_capacity(elifs.len())
        );
        let elif_count = elifs.len();
        for (cmp, body) in elifs {
            elif_cmps.push(cmp);
            elif_bodys.push(body);
        }
        debug_assert_eq!(elif_cmps.len(), elif_count);

        let mut res = Vec::new();
        res.push(Goto(true_start.clone(), cmp).into()); // true jump
        for (cmp, tag) in elif_cmps.into_iter().zip(&elif_tags) {
            res.push(Goto(tag.clone(), cmp).into()); // true jump
        }
        else_body.map(|body| res.push(body));
        res.push(Goto(end.clone(), JumpCmp::Always).into()); // jump always to end

        // elif body
        for (tag, body) in elif_tags.into_iter().zip(elif_bodys) {
            res.push(LogicLine::Label(tag));
            res.push(body);
            res.push(Goto(end.clone(), JumpCmp::Always).into()); // jump always to end
        }

        // true body
        res.push(LogicLine::Label(true_start));
        res.push(body);
        res.push(LogicLine::Label(end));

        Expand(res).into()
    },
}
