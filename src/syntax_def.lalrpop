// this is a lalrpop file
#![allow(clippy::just_underscores_and_digits)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::deprecated_cfg_attr)]

use crate::syntax::{
    Errors,
    Error,
    Op,
    Value,
    Var,
    DExp,
    ValueBind,
    JumpCmp,
    CmpTree,
    Goto,
    Expand,
    SwitchCatch,
    Select,
    Const,
    Take,
    LogicLine,
    Meta,
};

grammar(meta: &mut Meta);

extern {
    type Error = Error;
    type Location = Location;
}

match {
    r"\s+" => {}, // empty
    r##"#(?:[\r\n]|[^\*][^\r\n]*)"## => {}, // inline comments
    r##"#\*[^*]*\*+(?:[^#*][^*]*\*+)*#"## => {}, // long comments
} else {
    _
}

Or<A, B> = { A, B }; // A或者B
Or3<A, B, C> = { A, B, C }; // A或者B或者C
OrSwap<A, B> = { A B, B A }; // 匹配 `A B`或者`B A`
OrRev<A, M, B> = { A M B, B, M, A }; // 匹配`A M B`或者`B M A`
OrShl<A, B, C> = { A B C, B C A }; // 匹配`A B C`或者`B C A`, 后者是值进行左移循环得到
Wrap<Open, T, Close> = Open <T> Close; // 用于定义包裹
MTuple<T> = Wrap<"(", T, ")">;
MList<T> = Wrap<"[", T, "]">;
MBlock<T> = Wrap<"{", T, "}">;
OpenArgs<T, S> = (<T> S)*; // 零至多个有分隔后缀值
CloseArgs<T, S> = (<T> S)* T => { // 一至多个有分隔无后缀值
    let (mut args, tail) = <>;
    args.push(tail);
    args
};
Span<T> = @L T @R;

pub String: Var = r#""[^"]*""# => <>.lines().collect::<Vec<_>>().join("\\n");
pub Ident: Var = r"[_\p{XID_Start}]\p{XID_Continue}*" => <>.into();
pub OIdent: Var = r"@[_\p{XID_Start}][\p{XID_Continue}\-]*" => <>.into(); // `@abc-def`这种
pub Number: Var = r"(?:0(?:x-?[\da-fA-F][_\da-fA-F]*|b-?[01][_01]*)|-?\d[_\d]*(?:\.\d[\d_]*)?)"
    => <>.chars().filter(|&c| c != '_').collect();
// 原始字面量, 如`'@abc-def'`, 其中双引号会被替换为单引号.
// 在一对单引号内可以写任意非空字符, 可避开关键字等
pub OtherValue: Var = r"'[^'\s]+'" => {
    <>[1..<>.len()-1].replace('"', "\'")
};

// 逻辑里面一个单元
// 但不包含字符串
pub NoStringVar: Var = {
    Ident,
    OIdent,
    Number,
    OtherValue,
}
// 逻辑里面一个单元
// 例如`0x50` `'@alpha'` `add` `'a-b-c'`
pub Var: Var = {
    String,
    NoStringVar,
}

pub Value: Value = {
    Var => <>.into(),
    DExp => <>.into(),
    "`" <Var> "`" => Value::ReprVar(<>), // 原始值
    "$" => Value::ResultHandle,
    <name:Var> <args:MList<Value*>> => {
        // QuickDExpTake
        let len = args.len() + 1;
        let mut expand = Vec::with_capacity(len);
        Take::build_arg_consts_to_expand(args, &mut expand);
        expand.push(LogicLine::SetResultHandle(name.into()));
        DExp::new("__".into(), expand.into()).into()
    },
    <value:Value> "." <attr:NoStringVar> => ValueBind(value.into(), attr).into(),
}

pub LiteralUInt: usize = <l:@L> <num:Number> <r:@R> =>? {
    let mut chars = num.chars();
    let res = if let Some('0') = chars.next() {
        match chars.next() {
            Some('x') => usize::from_str_radix(&chars.collect::<String>(), 16),
            Some('b') => usize::from_str_radix(&chars.collect::<String>(), 2),
            _ => num.parse::<usize>(),
        }
    } else {
        num.parse::<usize>()
    };
    match res {
        Ok(num) => Ok(num),
        Err(e) => Err(Error::from(([l, r], Errors::NotALiteralUInteger(num, e))).into()),
    }
};


LEnd: () = ";" => ();

JumpCmpBody: JumpCmp = {
    <OrSwap<Or<"equal", "==">, <Value>>> <Value> => JumpCmp::Equal(<>),
    <OrSwap<Or<"notEqual", "!=">, <Value>>> <Value> => JumpCmp::NotEqual(<>),
    <OrSwap<Or<"lessThan", "<">, <Value>>> <Value> => JumpCmp::LessThan(<>),
    <OrSwap<Or<"lessThanEq", "<=">, <Value>>> <Value> => JumpCmp::LessThanEq(<>),
    <OrSwap<Or<"greaterThan", ">">, <Value>>> <Value> => JumpCmp::GreaterThan(<>),
    <OrSwap<Or<"greaterThanEq", ">=">, <Value>>> <Value> => JumpCmp::GreaterThanEq(<>),
    <OrSwap<Or<"strictEqual", "===">, <Value>>> <Value> => JumpCmp::StrictEqual(<>),
    Or<"always", "_"> => JumpCmp::Always,
    // 扩展
    <OrSwap<Or<"strictNotEqual", "!==">, <Value>>> <Value> => JumpCmp::StrictNotEqual(<>),
    <Value> => JumpCmp::bool(<>),
}

pub JumpCmp: CmpTree = CmpTree1;

pub CmpTree1: CmpTree = {
    <a:CmpTree1> "||" <b:CmpTree2> => CmpTree::Or(Box::new(a.into()), b.into()),
    CmpTree2,
}

pub CmpTree2: CmpTree = {
    <a:CmpTree2> "&&" <b:CmpTree3> => CmpTree::And(Box::new(a.into()), b.into()),
    CmpTree3,
}

pub CmpTree3: CmpTree = {
    Or<"lnot", "!"> <CmpTree3> => <>.reverse(),
    CmpTree,
}

pub CmpTree: CmpTree = {
    JumpCmpBody => <>.into(),
    MTuple<JumpCmp>,
}

pub Op: Op = {
    // 2
    <a:OrShl<Or<"add", "+">, <Value>, <Value>>> <b:Value> => Op::Add(a.0, a.1, b),
    <a:OrShl<Or<"sub", "-">, <Value>, <Value>>> <b:Value> => Op::Sub(a.0, a.1, b),
    <a:OrShl<Or<"mul", "*">, <Value>, <Value>>> <b:Value> => Op::Mul(a.0, a.1, b),
    <a:OrShl<Or<"div", "/">, <Value>, <Value>>> <b:Value> => Op::Div(a.0, a.1, b),
    <a:OrShl<Or<"idiv", "//">, <Value>, <Value>>> <b:Value> => Op::Idiv(a.0, a.1, b),
    <a:OrShl<Or<"mod", "%">, <Value>, <Value>>> <b:Value> => Op::Mod(a.0, a.1, b),
    <a:OrShl<Or<"pow", "**">, <Value>, <Value>>> <b:Value> => Op::Pow(a.0, a.1, b),
    <a:OrShl<Or<"equal", "==">, <Value>, <Value>>> <b:Value> => Op::Equal(a.0, a.1, b),
    <a:OrShl<Or<"notEqual", "!=">, <Value>, <Value>>> <b:Value> => Op::NotEqual(a.0, a.1, b),
    <a:OrShl<Or<"land", "&&">, <Value>, <Value>>> <b:Value> => Op::Land(a.0, a.1, b),
    <a:OrShl<Or<"lessThan", "<">, <Value>, <Value>>> <b:Value> => Op::LessThan(a.0, a.1, b),
    <a:OrShl<Or<"lessThanEq", "<=">, <Value>, <Value>>> <b:Value> => Op::LessThanEq(a.0, a.1, b),
    <a:OrShl<Or<"greaterThan", ">">, <Value>, <Value>>> <b:Value> => Op::GreaterThan(a.0, a.1, b),
    <a:OrShl<Or<"greaterThanEq", ">=">, <Value>, <Value>>> <b:Value> => Op::GreaterThanEq(a.0, a.1, b),
    <a:OrShl<Or<"strictEqual", "===">, <Value>, <Value>>> <b:Value> => Op::StrictEqual(a.0, a.1, b),
    <a:OrShl<Or<"shl", "<<">, <Value>, <Value>>> <b:Value> => Op::Shl(a.0, a.1, b),
    <a:OrShl<Or<"shr", ">>">, <Value>, <Value>>> <b:Value> => Op::Shr(a.0, a.1, b),
    <a:OrShl<Or<"or", "|">, <Value>, <Value>>> <b:Value> => Op::Or(a.0, a.1, b),
    <a:OrShl<Or<"and", "&">, <Value>, <Value>>> <b:Value> => Op::And(a.0, a.1, b),
    <a:OrShl<Or<"xor", "^">, <Value>, <Value>>> <b:Value> => Op::Xor(a.0, a.1, b),

    <OrSwap<"max", <Value>>> <Value> <Value> => Op::Max(<>),
    <OrSwap<"min", <Value>>> <Value> <Value> => Op::Min(<>),
    <OrSwap<"angle", <Value>>> <Value> <Value> => Op::Angle(<>),
    <OrSwap<"len", <Value>>> <Value> <Value> => Op::Len(<>),
    <OrSwap<"noise", <Value>>> <Value> <Value> => Op::Noise(<>),

    // 1
    // 此处使用`Value`来接受逻辑导出时的占位符
    <OrSwap<Or<"not", "~">, <Value>>> <Value> Value? => Op::Not(<>),
    <OrSwap<"abs", <Value>>> <Value> Value? => Op::Abs(<>),
    <OrSwap<"log", <Value>>> <Value> Value? => Op::Log(<>),
    <OrSwap<"log10", <Value>>> <Value> Value? => Op::Log10(<>),
    <OrSwap<"floor", <Value>>> <Value> Value? => Op::Floor(<>),
    <OrSwap<"ceil", <Value>>> <Value> Value? => Op::Ceil(<>),
    <OrSwap<"sqrt", <Value>>> <Value> Value? => Op::Sqrt(<>),
    <OrSwap<"rand", <Value>>> <Value> Value? => Op::Rand(<>),
    <OrSwap<"sin", <Value>>> <Value> Value? => Op::Sin(<>),
    <OrSwap<"cos", <Value>>> <Value> Value? => Op::Cos(<>),
    <OrSwap<"tan", <Value>>> <Value> Value? => Op::Tan(<>),
    <OrSwap<"asin", <Value>>> <Value> Value? => Op::Asin(<>),
    <OrSwap<"acos", <Value>>> <Value> Value? => Op::Acos(<>),
    <OrSwap<"atan", <Value>>> <Value> Value? => Op::Atan(<>),
    // 扩展(1)
    <OrSwap<Or<"lnot", "!">, <Value>>> <Value> Value? =>
        Op::Equal(<>, Value::ReprVar("false".into())),
}

Label: String = ":" <Var>;

pub Expand: Expand = LogicLine* => Expand(<>);
pub LogicLine: LogicLine = {
    Control,
    BuiltinCommand,
    MBlock<Expand> => <>.into(),
    Label => LogicLine::new_label(<>, meta),
    "op" <Op> LEnd => <>.into(),
    "noop" LEnd => LogicLine::NoOp,
    "set" <var:Value> <value:Value> LEnd => LogicLine::Other(vec![
        Value::ReprVar("set".into()),
        var.into(),
        value
    ]),
    <l:@L> <vars:PArgs> "=" <values:PArgs> LEnd <r:@R>
        =>? meta.build_sets([l, r], vars, values)
            .map_err(|e| e.into()),
    "print" <Args> LEnd => {
        if <>.is_empty() {
            // 无参数, 啥也不做
            return LogicLine::Ignore
        }
        if <>.len() == 1 {
            // 单个参数, 老式处理
            return LogicLine::Other(vec![
                Value::ReprVar("print".into()),
                <>.into_iter().next().unwrap()
            ])
        }
        Expand(
            <>.into_iter()
                .map(|arg| LogicLine::Other(vec![
                    Value::ReprVar("print".into()),
                    arg
                ]))
                .collect()
        ).into()
    },
    <args:PArgs> LEnd => {
        LogicLine::Other(args)
    },
}

Args: Vec<Value> = {
    () => vec![],
    PArgs,
}
PArgs: Vec<Value> = {
    Value => vec![<>],
    Value Value => vec![<>],
    Value Value Value => vec![<>],
    Value Value Value Value => vec![<>],
    Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value Value Value => vec![<>],
    Value Value Value Value Value Value Value Value Value Value Value Value Value => vec![<>],
}

ConstStart<T>: T = T => {
    // 开始一个const, 开启了必须负责清理
    // T是一个非空匹配, 因为如果用如`()`的空匹配会造成不执行, 因为没必要求值
    meta.add_label_scope();
    <>
};

pub BuiltinCommand: LogicLine = {
    "const" <var:Var> <_unused:ConstStart<"=">> <value:Value> LEnd
        => Const(var, value, meta.pop_label_scope()).into(),

    // 如果后方是一个Var则直接将常量映射到后方的值
    // 如果后方是一个DExp则将其计算然后将常量映射到计算出的句柄
    // 此处默认句柄使用Value
    "take" <args:MList<Value*>?> <var:(<Var> "=")?> <value:Value> LEnd => {
        let do_leak_res = var.is_some();

        Take::new(
            args.unwrap_or_default(),
            var.unwrap_or_else(|| String::from("__")),
            do_leak_res,
            value
        )
    },

    "setres" <Value> LEnd => LogicLine::SetResultHandle(<>),
}

BlockExpand: Expand = MBlock<Expand> => <>;
pub Block: LogicLine = BlockExpand => <>.into();

pub DExp: DExp = MTuple<(<(<Var> ":")?> <Expand>)>
    => DExp::new_optional_res(<>.0, <>.1);

SwitchCatchFlag: SwitchCatch = {
    "<" => SwitchCatch::Underflow,
    "!" => SwitchCatch::Misses,
    ">" => SwitchCatch::Overflow,
    MTuple<JumpCmp> => SwitchCatch::UserDefine(<>),
}

pub Control: LogicLine = {
    "goto" <Label> <JumpCmp> LEnd => Goto(<>).into(),

    "skip" <cmp:JumpCmp> <body:LogicLine> => {
        let lab = meta.get_tag();
        Expand(vec![
            Goto(lab.clone(), cmp).into(),
            body,
            LogicLine::new_label(lab, meta),
        ]).into()
    },

    "while" <cmp:JumpCmp> <body:LogicLine> => {
        let [end, head] = [meta.get_tag(), meta.get_tag()];
        let rev_cmp = cmp.clone().reverse();
        Expand(vec![
            Goto(end.clone(), rev_cmp).into(),
            LogicLine::new_label(head.clone(), meta),
            body,
            Goto(head, cmp).into(),
            LogicLine::new_label(end, meta),
        ]).into()
    },

    "do" <body:Block> "while" <cmp:JumpCmp> LEnd => {
        let head = meta.get_tag();
        Expand(vec![
            LogicLine::new_label(head.clone(), meta),
            body,
            Goto(head, cmp).into(),
        ]).into()
    },

    "gwhile" <cmp:JumpCmp> <body:LogicLine> => {
        let [to, head] = [meta.get_tag(), meta.get_tag()];
        Expand(vec![
            Goto(to.clone(), JumpCmp::Always.into()).into(),
            LogicLine::new_label(head.clone(), meta),
            body,
            LogicLine::new_label(to, meta),
            Goto(head, cmp).into(),
        ]).into()
    },

    "switch" <value:Value>
    <cases:MBlock<(
        <LogicLine?> // append line
        <( // catch 拦截
            "case"
            <SwitchCatchFlag+> // 捕获模式, 至少有一个
            // 可选的Var,
            // 会在捕获块头部使用const将该Var映射至已经求出的case跳转目标
            <Var?>
            ":"
            <Expand>
        )*>
        <( // cases
            "case"
            <LiteralUInt+>
            ":"
            <Expand>
        )+>
    )>>
    => {
        let (append, catchs, cases) = cases;
        let catchs_is_empty = catchs.is_empty();

        let case_num_max = cases
            .iter()
            .map(
                |(nums, _)| *nums
                    .iter()
                    .max()
                    .unwrap()
            )
            .max()
            .unwrap();
        let mut cases_res = Vec::with_capacity(case_num_max);

        // 用于填充填充case的行, 如果有追加在末尾的行则将其封装并替换填充
        let mut fill_line = append
            .as_ref()
            .map(|line| Expand(vec![line.clone()]).into())
            .unwrap_or(LogicLine::NoOp);

        // 用于添加到头部的捕获块
        let mut catch_lines = Vec::new();
        let value_handle: Var = if catchs_is_empty {
            Var::with_capacity(0)
        } else { meta.get_tmp_var() };

        // 这里开始遍历捕获
        // 如果遇到了未命中捕获, 则改变fill_line为总是跳转到未命中捕获
        for (flags, name, lines) in catchs {
            let mut out_block = Vec::new();
            let skip_cmp = CmpTree::new_ands(
                flags
                    .into_iter()
                    .filter(|flag| {
                        if flag.is_misses() {
                            // 是一个未命中捕获
                            let tag = meta.get_tag();
                            out_block.push(LogicLine::Label(tag.clone()));
                            fill_line = Goto(tag, JumpCmp::Always.into()).into();
                            false // 已处理, 过滤掉
                        } else {
                            true
                        }
                    })
                    .map(|flag|
                        flag.build(value_handle.as_str().into(), case_num_max)
                    )
            ).unwrap_or(JumpCmp::Always.into());
            let skip_tag = meta.get_tag();
            out_block.insert(0, Goto(skip_tag.clone(), skip_cmp).into());
            if let Some(name) = name {
                // 如果有捕获变量则使用一个const进行映射
                // 这需要插入在头部, 也就是条件前
                // 防止`case (a) a:`时, a还没被const就进行了判断
                out_block.insert(
                    0,
                    Const::new(
                        name,
                        value_handle.as_str().into()
                    ).into()
                )
            }
            out_block.push(lines.into());
            out_block.push(LogicLine::Label(skip_tag));

            catch_lines.push(Expand(out_block).into())
        }

        for (nums, mut expand) in cases {
            if let Some(append) = &append {
                expand.push(append.clone())
            }
            for num in nums {
                for _ in cases_res.len()..=num {
                    cases_res.push(fill_line.clone())
                }
                cases_res[num] = expand.clone().into()
            }
        }
        debug_assert_eq!(cases_res.len(), case_num_max + 1);

        if catchs_is_empty {
            // 没有捕获块
            Select(value, Expand(cases_res)).into()
        } else {
            // 保证我们拿到了一个临时返回句柄, 而不是一个空值
            assert_ne!(&value_handle, "");
            // 有捕获块
            Expand(vec![
                // 求值
                Take(value_handle.as_str().into(), value).into(),
                // 捕获
                Expand(catch_lines).into(),
                // 主体
                Select(value_handle.into(), Expand(cases_res)).into()
            ]).into()
        }
    },

    "select" <value:Value> <lines:BlockExpand> => Select(value, lines).into(),

    "if" <cmp:JumpCmp> <body:Block>
        <elifs:("elif" <JumpCmp> <Block>)*>
        <else_body:("else" <LogicLine>)?> => {

        // 对于没有elif和else的直接优化成skip
        if elifs.is_empty() && else_body.is_none() {
            let lab = meta.get_tag();
            return Expand(vec![
                Goto(lab.clone(), cmp.reverse()).into(),
                body,
                LogicLine::new_label(lab, meta),
            ]).into()
        }

        let end = meta.get_tag();
        let true_start = meta.get_tag();
        let mut elif_tags = Vec::with_capacity(elifs.len());
        elif_tags.extend((0..elifs.len()).map(|_| meta.get_tag())); // build elif tags
        let (mut elif_cmps, mut elif_bodys) = (
            Vec::with_capacity(elifs.len()),
            Vec::with_capacity(elifs.len())
        );
        let elif_count = elifs.len();
        for (cmp, body) in elifs {
            elif_cmps.push(cmp);
            elif_bodys.push(body);
        }
        debug_assert_eq!(elif_cmps.len(), elif_count);

        let mut res = Vec::new();
        res.push(Goto(true_start.clone(), cmp).into()); // true jump
        for (cmp, tag) in elif_cmps.into_iter().zip(&elif_tags) {
            res.push(Goto(tag.clone(), cmp).into()); // true jump
        }
        else_body.map(|body| res.push(body));
        res.push(Goto(end.clone(), JumpCmp::Always.into()).into()); // jump always to end

        // elif body
        for (tag, body) in elif_tags.into_iter().zip(elif_bodys) {
            res.push(LogicLine::new_label(tag, meta));
            res.push(body);
            res.push(Goto(end.clone(), JumpCmp::Always.into()).into()); // jump always to end
        }

        // true body
        res.push(LogicLine::new_label(true_start, meta));
        res.push(body);
        res.push(LogicLine::new_label(end, meta));

        Expand(res).into()
    },
}
