// this is a lalrpop file

#![allow(unused_braces)]
#![allow(clippy::all)]
#![allow(clippy::just_underscores_and_digits)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::deprecated_cfg_attr)]

use ::syntax::{
    Errors,
    Error,
    Op,
    Value::{
        self,
        ResultHandle,
        ReprVar,
    },
    Var,
    DExp,
    Cmper,
    ValueBind,
    ValueBindRef,
    ValueBindRefTarget,
    ClosuredValue,
    ClosuredValueMethod,
    op_expr_build_results,
    op_expr_tools::TOP_ASSIGN_OPER,
    make_assign_oper,
    make_if,
    OpExprInfo,
    OpExprType,
    OpExprAOperFun,
    JumpCmp,
    CmpTree,
    Goto,
    Expand,
    InlineBlock,
    SwitchCatch,
    Select,
    GSwitch,
    GSwitchCase,
    Const,
    Take,
    ConstKey,
    LogicLine,
    Args,
    ArgsRepeat,
    Match,
    MatchPat,
    MatchPatAtom,
    ConstMatch,
    ConstMatchPat,
    ConstMatchPatAtom,
    Meta,
    ZERO_VAR,
    FALSE_VAR,
};
use ::var_utils::string_escape;
use tag_code::logic_parser::IdxBox;

grammar(meta: &mut Meta);

extern {
    type Error = Error;
    type Location = Location;
}

match {
    r"\s+" => {}, // empty
    r##"#(?:[\r\n]|[^\*][^\r\n]*)"## => {}, // inline comments
    r##"#\*[^*]*\*+(?:[^#*][^*]*\*+)*#"## => {}, // long comments
} else {
    _
}

Or<A, B> = { A, B }; // A或者B
Or3<A, B, C> = { A, B, C }; // A或者B或者C
OrSwap<A, B> = { A B, B A }; // 匹配 `A B`或者`B A`
OrShl<A, B, C> = { A B C, B C A }; // 匹配`A B C`或者`B C A`, 后者是值进行左移循环得到
Wrap<Open, T, Close> = Open <T> Close; // 用于定义包裹
MTuple<T> = Wrap<"(", T, ")">;
MLTuple<L, T> = Wrap<"([", (<L> "]" <T>), ")">;
METuple<T> = Wrap<"(?", T, ")">;
MFTuple<T> = Wrap<"(%", T, ")">;
MFETuple<T> = Wrap<"(%", T, "%)">;
MList<T> = Wrap<"[", T, "]">;
MBlock<T> = Wrap<"{", T, "}">;
#[inline]
Cat<Acc, End>: Acc = <mut acc:Acc> <end:End> => { acc.push(end); acc };
#[inline]
Ext<Acc, End>: Acc = <mut acc:Acc> <end:End> => { acc.extend(end); acc };
#[inline]
IntoLL<T>: LogicLine = T => <>.into();
#[inline]
IntoV<T>: Value = T => <>.into();
#[inline]
IntoBoxV<T>: Box<Value> = IntoV<T> => <>.into();
#[inline]
OpenArgs<T, S> = (<T> S)*; // 零至多个有分隔后缀值
#[inline]
CloseArgs<T, S>: Vec<T> = Cat<OpenArgs<T, S>, T>; // 一至多个有分隔无后缀值
#[inline]
OOCArgs<T, S>: Vec<T> = {
    OpenArgs<T, S>,
    CloseArgs<T, S>,
}
#[inline]
COArgs<T, S>: Vec<T> = {
    <CloseArgs<T, S>> S?,
}
#[inline]
Opt<T>: bool = T? => <>.is_some();
MakeDExpBody<T>: DExp = {
    <var:(<Var> ":")?> <value:T>
        => DExp::new_optional_res(var, value.into()),
    <var:ReprVar> ":" <value:T>
        => DExp::new_notake(var, value.into()),
}
#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);
One<T>: Vec<T> = T => vec![<>];

#[inline]
Loc<T>: IdxBox<T> = @L T => IdxBox::new(<>);

CtrlBreakStart: () = () => meta.add_control_break_level(None);
CtrlContinueStart: () = () => meta.add_control_continue_level(None);
CtrlStart: () = () => meta.add_control_level(None, None);

CtrlBreakStop: Option<Var> = () => meta.pop_control_break_level();
CtrlContinueStop: Option<Var> = () => meta.pop_control_continue_level();
CtrlStop: (Option<Var>, Option<Var>) = () => meta.pop_control_level();

pub TopLevel: Expand = CtrlStart <mut lines:Expand> <ctrl:CtrlStop> => {
    let (break_lab, continue_lab) = ctrl;
    meta.push_some_label_to(&mut lines, break_lab);
    meta.push_some_label_to(&mut lines, continue_lab);
    lines
};

ReprVar: Var = {
    "`" <Var> "`" => Var::from(<>),
    "`" <Keywords> "`" => Var::from(<>),
}
String: Var = r#""(?:\\\r?\n\s*(?:\\ )?|\r?\n|\\[n\\\[]|[^"\r\n\\])*""#
    => string_escape(<>).into();
Ident: Var = r"[_\p{XID_Start}]\p{XID_Continue}*" => <>.into();
OIdent: Var = r"@[_\p{XID_Start}][\p{XID_Continue}\-]*" => <>.into(); // `@abc-def`这种
pub Number: Var = r"-?(?:0x-?[\da-fA-F][_\da-fA-F]*|0b-?[01][_01]*|\d[_\d]*(?:\.\d[\d_]*|e[+\-]?\d[\d_]*)?)"
    => <>.chars().filter(|&c| c != '_').collect();
// 原始字面量, 如`'@abc-def'`, 其中双引号会被替换为单引号.
// 在一对单引号内可以写任意非空字符, 可避开关键字等
OtherVar: Var = r"'[^'\s]+'" => {
    <>[1..<>.len()-1].replace('"', "\'").into()
};

// 逻辑里面一个单元
// 但不包含字符串
NoStringVar: Var = {
    Ident,
    OIdent,
    Number,
    OtherVar,
}
// 逻辑里面一个单元
// 例如`0x50` `'@alpha'` `add` `'a-b-c'`
pub Var: Var = {
    String,
    NoStringVar,
}

ValueBind<Left>: ValueBind = {
    <value:IntoBoxV<Left>> "." <attr:NoStringVar> => {
        ValueBind(value, attr)
    },
}

ConstKey: ConstKey = {
    ValueBind<NonConstRangeValue> => <>.into(),
    Var => <>.into(),
}

RCombValue<Left>: Left = {
    <value:IntoV<Left>> <args:MList<ParamArgs>> => {
        // QuickDExpTake
        DExp::new(meta.unnamed_var(), vec![
            LogicLine::SetArgs(args),
            LogicLine::SetResultHandle(value),
        ].into()).into()
    },
    <value:IntoBoxV<Left>> "->" <name:NoStringVar> => {
        let target = ValueBindRefTarget::NameBind(name);
        ValueBindRef::new(value, target.into()).into()
    },
    <value:IntoBoxV<Left>> "->" <l:Loc<"..">> => {
        ValueBindRef::new(value, ValueBindRefTarget::Binder(l.unit())).into()
    },
    <IntoBoxV<Left>> "->" "$" => {
        ValueBindRef::new(<>, ValueBindRefTarget::ResultHandle).into()
    },
    <IntoBoxV<Left>> "->" "op" => {
        ValueBindRef::new(<>, ValueBindRefTarget::Op).into()
    },
    <value:IntoV<Left>> "->" <args:MList<ParamArgs>> => {
        // Refed QuickDExpTake
        let dexp = DExp::new(meta.unnamed_var(), vec![
            LogicLine::SetArgs(args),
            LogicLine::SetResultHandle(value),
        ].into()).into();

        ValueBindRef::new(Box::new(dexp), ValueBindRefTarget::ResultHandle).into()
    },
}
RCombValueKeyLike<Left>: Value = {
    ConstKey => <>.into(),
    RCombValue<Left>,
}
RCombValuePure<Left>: Left = {
    ValueBind<Left> => <>.into(),
    RCombValue<Left>,
}

TrivialValue: Value = {
    Var => <>.into(),
    TrivialValueExt,
}
TrivialValueExt: Value = {
    "$" => ResultHandle,
    ".." => Value::Binder,
    ReprVar => ReprVar(<>), // 原始值
}

NonConstRangeValue: Value = {
    TrivialValueExt,
    <l:Loc<"goto">> <v:MTuple<Boxed<JumpCmpOnce>>> => Cmper(l.new_value(v)).into(),
    FEDExp => <>.into(),
    MFTuple<Value>,
    OpExprDExp => <>.into(),
    ClosuredValue => <>.into(),
    DExp => <>.into(),
    OpExprValueLike,
    ForceSettedValue,
    RCombValueKeyLike<NonConstRangeValue>,
}

pub Value: Value = {
    NonConstRangeValue,
    // consted-dexp
    "const" ConstStart <value:Or<ValueDExp, ("!" <Value>)>> <labels:ConstStop> => {
        let tmp_name = meta.get_tmp_var();
        let dexp_const = Const(tmp_name.clone().into(), value.into(), labels);
        DExp::new(meta.unnamed_var(), vec![
            dexp_const.into(),
            LogicLine::SetResultHandle(tmp_name.into()),
        ].into()).into()
    },
}

pub LiteralUInt: usize = <l:@L> <num:Number> <r:@R> =>? {
    let mut chars = num.chars();
    let res = if let Some('0') = chars.next() {
        match chars.next() {
            Some('x') => usize::from_str_radix(&chars.collect::<String>(), 16),
            Some('b') => usize::from_str_radix(&chars.collect::<String>(), 2),
            _ => num.parse::<usize>(),
        }
    } else {
        num.parse::<usize>()
    };
    match res {
        Ok(num) => Ok(num),
        Err(e) => Err(Error::from(([l, r], Errors::NotALiteralUInteger(num, e))).into()),
    }
};


LEnd: () = ";" => ();

CmpVAT: Value = {
    Value,
    CmpValueExtAtom => <>.into(),
    "++" <Value> => {
        DExp::new(meta.unnamed_var(), vec![
            LogicLine::SetResultHandle(<>),
            Op::Add(ResultHandle, ResultHandle, ReprVar("1".into())).into(),
        ].into()).into()
    },
    "--" <Value> => {
        DExp::new(meta.unnamed_var(), vec![
            LogicLine::SetResultHandle(<>),
            Op::Sub(ResultHandle, ResultHandle, ReprVar("1".into())).into(),
        ].into()).into()
    },
}

JumpCmpBody: JumpCmp = {
    <OrSwap<Or<"equal", "==">, <CmpVAT>>> <CmpVAT> => JumpCmp::Equal(<>),
    <OrSwap<Or<"notEqual", "!=">, <CmpVAT>>> <CmpVAT> => JumpCmp::NotEqual(<>),
    <OrSwap<Or<"lessThan", "<">, <CmpVAT>>> <CmpVAT> => JumpCmp::LessThan(<>),
    <OrSwap<Or<"lessThanEq", "<=">, <CmpVAT>>> <CmpVAT> => JumpCmp::LessThanEq(<>),
    <OrSwap<Or<"greaterThan", ">">, <CmpVAT>>> <CmpVAT> => JumpCmp::GreaterThan(<>),
    <OrSwap<Or<"greaterThanEq", ">=">, <CmpVAT>>> <CmpVAT> => JumpCmp::GreaterThanEq(<>),
    <OrSwap<Or<"strictEqual", "===">, <CmpVAT>>> <CmpVAT> => JumpCmp::StrictEqual(<>),
    Or<"always", "_"> => JumpCmp::Always,
    // 扩展
    <OrSwap<Or<"strictNotEqual", "!==">, <CmpVAT>>> <CmpVAT> => JumpCmp::StrictNotEqual(<>),
    <CmpVAT> => JumpCmp::bool(<>),
}

// 入口
pub JumpCmp: CmpTree = CmpTree2;
JumpCmpOnce: CmpTree = CmpTree1;

// 可空的, 空时为总是的条件
AlwaysJumpCmp: CmpTree = JumpCmp? => <>.unwrap_or(JumpCmp::Always.into());
AlwaysJumpCmpOnce: CmpTree = JumpCmpOnce? => <>.unwrap_or(JumpCmp::Always.into());

CmpTree1: CmpTree = {
    <deps:InlineBlock> "=>" <cmp:CmpTree1> => {
        CmpTree::Deps(deps.into(), cmp.into())
    },
    "=>" <CmpTree2>,
    CmpTree2,
}

CmpTree2: CmpTree = {
    <a:CmpTree2> Or<"||", "or"> <b:CmpTree3> => CmpTree::Or(Box::new(a.into()), b.into()),
    CmpTree3,
}

CmpTree3: CmpTree = {
    <a:CmpTree3> Or<"&&", "and"> <b:CmpTree4> => CmpTree::And(Box::new(a.into()), b.into()),
    CmpTree4,
}

CmpTree4: CmpTree = {
    Or3<"lnot", "not", "!"> <CmpTree4> => <>.reverse(),
    <args:MList<ParamArgs>> <cmp:CmpTree4> => {
        CmpTree::Deps(vec![
            LogicLine::SetArgs(args),
        ].into(), cmp.into())
    },
    CmpTree,
}

CmpTree: CmpTree = {
    JumpCmpBody => <>.into(),
    MTuple<JumpCmpOnce>,
}

Op: Op = {
    // 2
    <a:OrShl<Or<"add", "+">, <Value>, <Value>>> <b:Value> => Op::Add(a.0, a.1, b),
    <a:OrShl<Or<"sub", "-">, <Value>, <Value>>> <b:Value> => Op::Sub(a.0, a.1, b),
    <a:OrShl<Or<"mul", "*">, <Value>, <Value>>> <b:Value> => Op::Mul(a.0, a.1, b),
    <a:OrShl<Or<"div", "/">, <Value>, <Value>>> <b:Value> => Op::Div(a.0, a.1, b),
    <a:OrShl<Or<"idiv", "//">, <Value>, <Value>>> <b:Value> => Op::Idiv(a.0, a.1, b),
    <a:OrShl<Or<"mod", "%">, <Value>, <Value>>> <b:Value> => Op::Mod(a.0, a.1, b),
    <a:OrShl<Or<"emod", "%%">, <Value>, <Value>>> <b:Value> => Op::EMod(a.0, a.1, b),
    <a:OrShl<Or<"pow", "**">, <Value>, <Value>>> <b:Value> => Op::Pow(a.0, a.1, b),
    <a:OrShl<Or<"equal", "==">, <Value>, <Value>>> <b:Value> => Op::Equal(a.0, a.1, b),
    <a:OrShl<Or<"notEqual", "!=">, <Value>, <Value>>> <b:Value> => Op::NotEqual(a.0, a.1, b),
    <a:OrShl<Or<"land", "&&">, <Value>, <Value>>> <b:Value> => Op::Land(a.0, a.1, b),
    <a:OrShl<Or<"lessThan", "<">, <Value>, <Value>>> <b:Value> => Op::LessThan(a.0, a.1, b),
    <a:OrShl<Or<"lessThanEq", "<=">, <Value>, <Value>>> <b:Value> => Op::LessThanEq(a.0, a.1, b),
    <a:OrShl<Or<"greaterThan", ">">, <Value>, <Value>>> <b:Value> => Op::GreaterThan(a.0, a.1, b),
    <a:OrShl<Or<"greaterThanEq", ">=">, <Value>, <Value>>> <b:Value> => Op::GreaterThanEq(a.0, a.1, b),
    <a:OrShl<Or<"strictEqual", "===">, <Value>, <Value>>> <b:Value> => Op::StrictEqual(a.0, a.1, b),
    <a:OrShl<Or<"shl", "<<">, <Value>, <Value>>> <b:Value> => Op::Shl(a.0, a.1, b),
    <a:OrShl<Or<"shr", ">>">, <Value>, <Value>>> <b:Value> => Op::Shr(a.0, a.1, b),
    <a:OrShl<Or<"ushr", ">>>">, <Value>, <Value>>> <b:Value> => Op::UShr(a.0, a.1, b),
    <a:OrShl<Or<"or", "|">, <Value>, <Value>>> <b:Value> => Op::Or(a.0, a.1, b),
    <a:OrShl<Or<"and", "&">, <Value>, <Value>>> <b:Value> => Op::And(a.0, a.1, b),
    <a:OrShl<Or<"xor", "^">, <Value>, <Value>>> <b:Value> => Op::Xor(a.0, a.1, b),

    <OrSwap<"max", <Value>>> <Value> <Value> => Op::Max(<>),
    <OrSwap<"min", <Value>>> <Value> <Value> => Op::Min(<>),
    <OrSwap<"angle", <Value>>> <Value> <Value> => Op::Angle(<>),
    <OrSwap<"angleDiff", <Value>>> <Value> <Value> => Op::AngleDiff(<>),
    <OrSwap<"len", <Value>>> <Value> <Value> => Op::Len(<>),
    <OrSwap<"noise", <Value>>> <Value> <Value> => Op::Noise(<>),
    <OrSwap<"logn", <Value>>> <Value> <Value> => Op::LogN(<>),

    // 1
    // 此处使用`Value`来接受逻辑导出时的占位符
    <OrSwap<Or<"not", "~">, <Value>>> <Value> Value? => Op::Not(<>),
    <OrSwap<"abs", <Value>>> <Value> Value? => Op::Abs(<>),
    <OrSwap<"sign", <Value>>> <Value> Value? => Op::Sign(<>),
    <OrSwap<"log", <Value>>> <Value> Value? => Op::Log(<>),
    <OrSwap<"log10", <Value>>> <Value> Value? => Op::Log10(<>),
    <OrSwap<"floor", <Value>>> <Value> Value? => Op::Floor(<>),
    <OrSwap<"ceil", <Value>>> <Value> Value? => Op::Ceil(<>),
    <OrSwap<"round", <Value>>> <Value> Value? => Op::Round(<>),
    <OrSwap<"sqrt", <Value>>> <Value> Value? => Op::Sqrt(<>),
    <OrSwap<"rand", <Value>>> <Value> Value? => Op::Rand(<>),
    <OrSwap<"sin", <Value>>> <Value> Value? => Op::Sin(<>),
    <OrSwap<"cos", <Value>>> <Value> Value? => Op::Cos(<>),
    <OrSwap<"tan", <Value>>> <Value> Value? => Op::Tan(<>),
    <OrSwap<"asin", <Value>>> <Value> Value? => Op::Asin(<>),
    <OrSwap<"acos", <Value>>> <Value> Value? => Op::Acos(<>),
    <OrSwap<"atan", <Value>>> <Value> Value? => Op::Atan(<>),
    // 扩展(1)
    <OrSwap<Or<"lnot", "!">, <Value>>> <Value> Value? =>
        Op::Equal(<>, ReprVar(FALSE_VAR.into())),
    // 扩展(2)
    <a:OrShl<Or<"strictNotEqual", "!==">, <Value>, <Value>>> <b:Value> =>
        Op::Equal(
            a.0,
            DExp::new_nores(vec![
                Op::StrictEqual(ResultHandle, a.1, b).into()
            ].into()).into(),
            ReprVar(FALSE_VAR.into())
        ),
}

Label: Var = ":" <Var>;

#[inline]
Lines: Vec<LogicLine> = Ext<LogicLine*, LogicLineSingle?>;
LinesBlock: Vec<LogicLine> = MBlock<Lines>;
InlineBlock: InlineBlock = LinesBlock => <>.into();

#[inline]
Expand: Expand = Lines => Expand(<>);
pub LogicLine: LogicLine = {
    LogicLineNormal,
    <LogicLineSingle> LEnd,
}
LogicLineNormal: LogicLine = {
    Control,
    IntoLL<MBlock<Expand>>,
    "inline" <IntoLL<InlineBlock>>,
    Label => LogicLine::new_label(<>, meta),
    <OpExprTopSelfOps> LEnd,
    <OtherLogicLineZL> LEnd => meta.pack_line(LogicLine::Other(<>)),
    "inline" <ArgsRepeatBlock> => <>.into(),
    Match,
    ConstMatch,
}
LogicLineSingle: LogicLine = {
    "op" <IntoLL<Op>>,
    "noop" => LogicLine::NoOp,
    Print,
    OpExpr,
    QuickTake,
    ControlSingle,
    BuiltinCommand,
    OtherLogicLine => meta.pack_line(LogicLine::Other(<>)),
}

QuickTake: LogicLine = <value:Loc<NonConstRangeValue>> "!" <args:ParamArgsSL> => {
    let expand = Expand(vec![
        LogicLine::SetArgs(args),
        Take::unused(meta, value).into(),
    ]);
    meta.pack_line(expand.into())
};

Match: LogicLine = {
    "match" <args:Loc<ParamArgs>> <cases:MBlock<(
        <MatchPat*> <("@" <MatchPat*>)?> <LinesBlock>
    )*>> => {
        Match::new(args, cases.into_iter()
            .map(|(prep, sufp, body)| {
                (if let Some(sufp) = sufp {
                    MatchPat::Expanded(prep, sufp)
                } else {
                    MatchPat::Normal(prep)
                }, body.into())
            })
            .collect()
        ).into()
    },
    "match" <args:Loc<ParamArgs>> "=>" <case:(
        <MatchPat*> <("@" <MatchPat*>)?> <LinesBlock>
    )> => {
        Match::new(args, vec![case].into_iter()
            .map(|(prep, sufp, body)| {
                (if let Some(sufp) = sufp {
                    MatchPat::Expanded(prep, sufp)
                } else {
                    MatchPat::Normal(prep)
                }, body.into())
            })
            .collect()
        ).into()
    },
}

MatchPat: MatchPatAtom = {
    <sr:Opt<"$">> <pat:MList<Args1>> => MatchPatAtom::new_unamed(pat, sr),
    <sr:Opt<"$">> "_" => MatchPatAtom::new_unamed(vec![], sr),
    <sr:Opt<"$">> <v:Var> => MatchPatAtom::new(v, vec![], sr),
    <sr:Opt<"$">> <name:Var> ":" <pat:MList<Args1>> => MatchPatAtom::new(name, pat, sr),
}

ConstMatch: LogicLine = {
    "const" "match" <args:Loc<ParamArgs>> <cases:MBlock<(
        ConstMatchPat InlineBlock
    )*>> => {
        ConstMatch::new(args, cases).into()
    },
    "const" "match" <args:Loc<ParamArgs>> "=>" <case:(
        ConstMatchPat InlineBlock
    )> => {
        ConstMatch::new(args, vec![case]).into()
    },
}

ConstMatchPat: ConstMatchPat = {
    ConstMatchPatAtom* => ConstMatchPat::Normal(<>),
    <ConstMatchPatAtom*> <Opt<"*">> "@" <ConstMatchPatAtom*>
        => ConstMatchPat::Expanded(<>),
}

ConstMatchPatAtom: ConstMatchPatAtom = {
    <sr:Opt<"$">> <dotake:Opt<"*">> <name:(<Var> ":")?> <pat:MList<Args1>> => {
        ConstMatchPatAtom::new(dotake, name.unwrap_or_default(), pat, sr)
    },
    <sr:Opt<"$">> <dotake:Opt<"*">> <name:(<Var> ":")?> <pat:MList<("?" <OpExprBodyOne>)>> => {
        ConstMatchPatAtom::new_guard(
            dotake,
            name.unwrap_or_default(),
            pat.into_value(meta),
            sr,
        )
    },
    <sr:Opt<"$">> <dotake:Loc<Opt<"*">>> <name:(<Var> ":")?> <pat:MList<("*" <Args0>)>> => {
        let dexp = DExp::new(meta.unnamed_var(), vec![
            LogicLine::from(Match::new(
                dotake.new_value(Args::GLOB_ONLY),
                vec![
                    (
                        vec![MatchPatAtom::new_unamed(pat, false)].into(),
                        vec![
                            LogicLine::SetResultHandle(
                                Value::ReprVar("1".into())
                            ),
                        ].into(),
                    ),
                    (
                        vec![MatchPatAtom::default()].into(),
                        vec![
                            LogicLine::SetResultHandle(
                                Value::ReprVar("0".into())
                            ),
                        ].into(),
                    ),
                ]
            )),
        ].into());
        ConstMatchPatAtom::new_guard(
            dotake.value,
            name.unwrap_or_default(),
            dexp.into(),
            sr,
        )
    },
    <sr:Opt<"$">> <dotake:Opt<"*">> <name:Var> => {
        ConstMatchPatAtom::new(dotake, name, vec![], sr)
    },
    "$" "_" => {
        ConstMatchPatAtom::new(false, Default::default(), vec![], true)
    },
    <dotake:Opt<"*">> "_" => {
        ConstMatchPatAtom::new(dotake, Default::default(), vec![], false)
    },
}

APValueExtAtom: &'input str = {
    // NOTE: 不要加入 match, switch, 给可能的语法留下空位
    "_", "op", "noop", "print", "skip", "break", "continue",
    CmpValueExtAtom,
}
CmpValueExtAtom: &'input str = {
    "rand", "len", "sqrt", "angle", "pow", "log", "logn", "cos", "floor", "ceil", "round",
    "max", "min", "land", "abs", "sign", "shr", "ushr",
}
Keywords: &'input str = {
    "_", "goto", "not", "abs", "sign", "greaterThan", "notEqual",
    "acos", "greaterThanEq", "op", "add", "gswitch", "or",
    "always", "gwhile", "pow", "and", "idiv", "print",
    "angle", "if", "rand", "angleDiff", "inline", "select",
    "asin", "land", "setres", "atan", "len", "shl", "ushr",
    "break", "lessThan", "shr", "case", "lessThanEq", "sin",
    "ceil", "round", "lnot", "skip", "const", "log", "logn", "sqrt",
    "continue", "log10", "strictEqual", "cos", "match", "strictNotEqual",
    "div", "max", "sub", "do", "min", "switch",
    "elif", "mod", "emod", "take", "else", "mul", "tan",
    "equal", "noise", "while", "floor", "noop", "xor",
    OpKeywords,
}
OpKeywords: &'input str = {
    "+" => "add",
    "-" => "sub",
    "*" => "mul",
    "/" => "div",
    "//" => "idiv",
    "%" => "mod",
    "%%" => "emod",
    "**" => "pow",
    "==" => "equal",
    "!=" => "notEqual",
    "&&" => "land",
    "<" => "lessThan",
    "<=" => "lessThanEq",
    ">" => "greaterThan",
    ">=" => "greaterThanEq",
    "===" => "strictEqual",
    "<<" => "shl",
    ">>" => "shr",
    ">>>" => "ushr",
    "|" => "or",
    "&" => "and",
    "^" => "xor",
    "~" => "not",
}
APValueExt: Value = {
    APValueExtAtom => Var::from(<>).into(),
}
Args: Args = {
    <prefix:Args0> "@" <suffix:Args0> => {
        Args::Expanded(prefix, suffix)
    },
    <args:Args1> => {
        args.into()
    },
}
ArgsSL: Args = {
    <prefix:Args0G<(<SLValue> ","?)>> "@" ","? <suffix:Args0G<(<SLValue> ","?)>> => {
        Args::Expanded(prefix, suffix)
    },
    <args:Args1G<(<SLValue> ","?)>> => {
        args.into()
    },
}
SLValue: Value = {
    SLAtomImpl<MBlock<LocalVar>>,
    MBlock<LocalVar>,
    APValueExt,
    SLAtom<Value>,
}
SLPValue: Value = {
    "+" <SLAtomImpl<LocalVar>>,
    "+" <LocalVar>,
    SLValue,
}
ArgRestSL: Vec<Value> = {
    LinePack<"+"> <fst:LocalVar> <mut rest:Args0G<(","? <SLPValue>)>> => {
        rest.insert(0, fst);
        rest
    },
    <fst:LinePack<Value>> <mut rest:Args0G<(","? <SLValue>)>> => {
        rest.insert(0, fst);
        rest
    },
};
ArgRestSLLong: Vec<Value> = {
    LinePack<"+"> <fst:LocalVar> <mut rest:Args1G<(","? <SLPValue>)>> => {
        rest.insert(0, fst);
        rest
    },
    <fst:LinePack<Value>> <mut rest:Args1G<(","? <SLValue>)>> => {
        rest.insert(0, fst);
        rest
    },
};
OtherLogicLine: Args = {
    LinePack<"@"> <suffix:Args0G<SLValue>> => {
        Args::Expanded(vec![], suffix)
    },
    <prefix:ArgRestSL> "@" <suffix:Args0G<SLValue>> => {
        Args::Expanded(prefix, suffix)
    },
    <args:ArgRestSLLong> => {
        args.into()
    },
}
OtherLogicLineZL: Args = LinePack<Value> => vec![<>].into();
ParamArgsAtom: Value = {
    "*" <Value> => {
        ValueBindRef::new(<>.into(), ValueBindRefTarget::ResultHandle).into()
    },
    APValueExt,
    Value,
};
SLAtom<V>: V = {
    V,
    SLAtomImpl<SimpVar<V>> => <>.into(),
};
SLAtomImpl<V>: V = {
    <V> "++" => {
        meta.add_line_post(Op::Add(
            <>.clone().into(),
            <>.clone().into(),
            ReprVar("1".into()),
        ).into());
        <>.into()
    },
    <V> "--" => {
        meta.add_line_post(Op::Sub(
            <>.clone().into(),
            <>.clone().into(),
            ReprVar("1".into()),
        ).into());
        <>.into()
    },
};
LocalVar: Value = Var => {
    meta.add_line_dep(Take(
        <>.clone().into(),
        DExp::new_nores(vec![].into()).into(),
    ).into());
    <>.into()
};
SimpVar<V>: Var = V => {
    let tmp = meta.get_tmp_var();
    meta.add_line_dep(Take(tmp.clone().into(), <>.into()).into());
    tmp
};
ParamArgsAtomC: Value = <ParamArgsAtom> ","?;
ParamArgsSLAtomInner: Value = {
    "+" <LocalVar>,
    ParamArgsAtom,
}
ParamArgsSLAtom: Value = <SLAtom<ParamArgsSLAtomInner>> ","?;
LinePackBegin: () = () => meta.add_line_pack();
LinePack<V>: V = V => { meta.add_line_pack(); <> };
ParamArgsSL: Args = {
    LinePackBegin <prefix:ParamArgsSLAtom*> "@" ","? <suffix:ParamArgsSLAtom*> => {
        Args::Expanded(prefix, suffix)
    },
    LinePackBegin <args:ParamArgsSLAtom*> => {
        args.into()
    },
}
ParamArgs: Args = {
    <prefix:ParamArgsAtomC*> "@" ","? <suffix:ParamArgsAtomC*> => {
        Args::Expanded(prefix, suffix)
    },
    <args:ParamArgsAtomC*> => {
        args.into()
    },
}
ArgsRepeatBlock: ArgsRepeat = {
    <chunk:Loc<LiteralUInt?>> "@" <block:InlineBlock> =>? {
        Ok(ArgsRepeat::new(chunk.map(|n| n.unwrap_or(1)), block))
    },
    "*" <value:Loc<NonConstRangeValue>> "@" <block:InlineBlock> => {
        ArgsRepeat::new_valued(value, block)
    },
    <l:Loc<"@">> <pats:Loc<ConstMatchPatAtom+>> <block:InlineBlock> => {
        let glob = pats.new_value(Args::GLOB_ONLY);
        ArgsRepeat::new(l.new_value(pats.len()), vec![
            ConstMatch::new(glob, vec![
                (pats.value.into(), block),
            ]).into()
        ].into())
    },
}

Print: LogicLine = <l:LinePack<Loc<"print">>> ","? <args:ArgsSL?> => {
    fn one(arg: Value) -> LogicLine {
        LogicLine::Other(vec![
            ReprVar("print".into()),
            arg,
        ].into())
    }
    fn make(meta: &mut Meta, l: IdxBox<&str>, args: Option<Args>)
    -> LogicLine
    {
        let Some(args) = args else {
            // 无参数, 啥也不做
            return LogicLine::Ignore
        };
        match args {
            Args::Normal(mut args) if args.len() == 1 => {
                // 单个参数, 老式处理
                return one(args.pop().unwrap())
            },
            Args::Normal(args) => {
                Expand(
                    args.into_iter()
                        .map(|arg| one(arg))
                        .collect()
                ).into()
            },
            Args::Expanded(p, s) if p.len() == 0 && s.len() == 0 => {
                ArgsRepeat::new(l.new_value(1), vec![
                    LogicLine::Other(Args::Expanded(
                        vec![ReprVar("print".into())],
                        vec![],
                    )),
                ].into()).into()
            },
            Args::Expanded(prefix, suffix) => {
                let len = prefix.len() + 1 + suffix.len();
                let mut res = Vec::with_capacity(len);

                for arg in prefix {
                    res.push(one(arg))
                }

                res.push(ArgsRepeat::new(l.new_value(1), vec![
                    LogicLine::Other(Args::Expanded(vec![
                        ReprVar("print".into()),
                    ], vec![]))
                ].into()).into());

                for arg in suffix {
                    res.push(one(arg))
                }

                assert_eq!(res.len(), len);
                InlineBlock(res).into()
            },
        }
    }
    let line = make(&mut *meta, l, args);
    meta.pack_line(line)
};

// 0..
Args0: Vec<Value> = Args0G<Value>;
// 1..
Args1: Vec<Value> = Args1G<Value>;
// 2..
Args2: Vec<Value> = Args2G<Value>;

Args0G<V>: Vec<V> = {
    () => vec![],
    Args1G<V>,
}
Args1G<V>: Vec<V> = {
    V => vec![<>],
    Args2G<V>,
}
Args2G<V>: Vec<V> = {
    <fst:V> <mut rest:V+> => {
        rest.insert(0, fst);
        rest
    },
}

OpExprOp: (OpExprAOperFun, OpExprInfo) = {
    <oper:OpExprAssignOper> Or<"?", "*">?
    <values:CloseArgs<OpExprBody, ",">>
    => { (oper, OpExprInfo::from_iter(values)) },
}

OpExpr: LogicLine = {
    <l:@L> <mut results:ArgRestSL> <r:@R> <ops:OpExprOp+> =>? {
        if ops.len() > 1 {
            results = results.into_iter().map(|result: Value| {
                let tmp = meta.get_tmp_var();
                meta.add_line_dep(Take(tmp.clone().into(), result).into());
                tmp.into()
            }).collect();
        }
        let mut lines = Vec::with_capacity(ops.len());
        let mut ops = ops.into_iter().peekable();
        loop {
            let (oper, values) = ops.next().unwrap();
            match (results.len(), values.exprs.len()) {
                (_, 1) => (),
                (a, b) if a == b => (),
                (found, right) => {
                    return Err(Error::from((
                        [l, r],
                        Errors::OpExprInvalidResult { found, right },
                    )).into())
                }
            }
            if ops.peek().is_none() {
                lines.push(op_expr_build_results(&mut *meta, results, values.into(), oper));
                break;
            }
            lines.push(op_expr_build_results(&mut *meta, results.clone(), values.into(), oper));
        }
        Ok(meta.pack_line(if lines.len() == 1 {
            lines.pop().unwrap()
        } else {
            Expand(lines).into()
        }))
    }
}
OpExprBodySetR: Expand = OpExprBodyOne => {
    let line = op_expr_build_results(
        meta,
        vec![ResultHandle], vec![<>],
        |meta, res, v| v.into_logic_line(meta, res),
    );
    vec![line].into()
};
OpExprBodyToValue: Value = OpExprToValue<OpExprBody>;
OpExprDExp: DExp = METuple<(<MakeDExpBody<OpExprBodySetR>> ","?)>;
OpExprValueLike: Value = MTuple<("*" <OpExprBodyToValue> ","?)>;
ForceSettedValue: Value = {
    MTuple<(<(<Var> ":")?> "=" <OpExprBodyOne> ","?)> => {
        let (result, expr) = <>;
        DExp::new(result.unwrap_or_default(), vec![
            Expand(vec![
                expr.into_logic_line(meta, ResultHandle)
            ]).into(),
        ].into()).into()
    },
    MTuple<(<(<ReprVar> ":")> "=" <OpExprBodyOne> ","?)> => {
        let (result, expr) = <>;
        DExp::new_notake(result, vec![
            Expand(vec![
                expr.into_logic_line(meta, ResultHandle)
            ]).into(),
        ].into()).into()
    },
}

OpExprAssignOper: OpExprAOperFun = {
    "+="            => { make_assign_oper!(Op::Add      ) },
    "-="            => { make_assign_oper!(Op::Sub      ) },
    "*="            => { make_assign_oper!(Op::Mul      ) },
    "/="            => { make_assign_oper!(Op::Div      ) },
    "//="           => { make_assign_oper!(Op::Idiv     ) },
    "%="            => { make_assign_oper!(Op::Mod      ) },
    "%%="           => { make_assign_oper!(Op::EMod     ) },
    "**="           => { make_assign_oper!(Op::Pow      ) },
    "&&="           => { make_assign_oper!(Op::Land     ) },
    "<<="           => { make_assign_oper!(Op::Shl      ) },
    ">>="           => { make_assign_oper!(Op::Shr      ) },
    ">>>="          => { make_assign_oper!(Op::UShr     ) },
    "|="            => { make_assign_oper!(Op::Or       ) },
    "&="            => { make_assign_oper!(Op::And      ) },
    "^="            => { make_assign_oper!(Op::Xor      ) },
    "max="          => { make_assign_oper!(Op::Max      ) },
    "min="          => { make_assign_oper!(Op::Min      ) },
    "="             => { TOP_ASSIGN_OPER },
}

OpExprBody: OpExprInfo = OpExprBody13;
OpExprOne<Body>: OpExprType = <l:@L> <x:Body> <r:@R> =>? {
    let x: OpExprInfo = x.into();
    if x.exprs.len() == 1 {
        Ok(x.exprs.into_iter().next().unwrap())
    } else {
        Err(Error::from(([l, r], Errors::MultipleOpExpr)).into())
    }
};
OpExprBodyOne: OpExprType = OpExprOne<OpExprBody>;
OpExprToValue<Body>: Value = OpExprOne<Body> => <>.into_value(meta);

OpExprBody13: OpExprInfo = {
    "if" <cmp:JumpCmpOnce> "?" <a:OpExprBody13> ":" <b:OpExprBody13> => {
        a.new_if_else(meta, cmp, b)
    },
    "select" <cond:JumpCmpBody> "?" <a:OpExprBody13> ":" <b:OpExprBody13> => {
        a.new_select(meta, cond, b)
    },
    OpExprBody12,
}

OpExprBody12: OpExprInfo = {
    <a:OpExprBody12> "||" <b:OpExprBody11> => a.new_op2(b,
        |a, b| Op::Add(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody11,
}

OpExprBody11: OpExprInfo = {
    <a:OpExprBody11> "&&" <b:OpExprBody10> => a.new_op2(b,
        |a, b| Op::Land(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody10,
}

OpExprBody10: OpExprInfo = {
    <a:OpExprBody9> "==" <b:OpExprBody9> => a.new_op2(b,
        |a, b| Op::Equal(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody9> "!=" <b:OpExprBody9> => a.new_op2(b,
        |a, b| Op::NotEqual(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody9> "===" <b:OpExprBody9> => a.new_op2(b,
        |a, b| Op::StrictEqual(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody9> "!==" <b:OpExprBody9> =>
        a.new_op2(b, |a, b| Op::Equal(
            ResultHandle,
            DExp::new_nores(vec![
                Op::StrictEqual(ResultHandle, a.into_value(meta), b.into_value(meta)).into()
            ].into()).into(),
            ReprVar(FALSE_VAR.into())
        )),
    OpExprBody9,
}
OpExprBody9: OpExprInfo = {
    <a:OpExprBody8> "<" <b:OpExprBody8> => a.new_op2(b,
        |a, b| Op::LessThan(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody8> ">" <b:OpExprBody8> => a.new_op2(b,
        |a, b| Op::GreaterThan(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody8> "<=" <b:OpExprBody8> => a.new_op2(b,
        |a, b| Op::LessThanEq(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody8> ">=" <b:OpExprBody8> => a.new_op2(b,
        |a, b| Op::GreaterThanEq(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody8,
}

OpExprBody8: OpExprInfo = {
    <a:OpExprBody8> "|" <b:OpExprBody7> => a.new_op2(b,
        |a, b| Op::Or(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody7,
}

OpExprBody7: OpExprInfo = {
    <a:OpExprBody7> "^" <b:OpExprBody6> => a.new_op2(b,
        |a, b| Op::Xor(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody6,
}

OpExprBody6: OpExprInfo = {
    <a:OpExprBody6> "&" <b:OpExprBody5> => a.new_op2(b,
        |a, b| Op::And(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody5,
}

OpExprBody5: OpExprInfo = {
    <a:OpExprBody5> "<<" <b:OpExprBody4> => a.new_op2(b,
        |a, b| Op::Shl(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody5> ">>" <b:OpExprBody4> => a.new_op2(b,
        |a, b| Op::Shr(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody5> ">>>" <b:OpExprBody4> => a.new_op2(b,
        |a, b| Op::UShr(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody4,
}

OpExprBody4: OpExprInfo = {
    <a:OpExprBody4> "+" <b:OpExprBody3> => a.new_op2(b,
        |a, b| Op::Add(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody4> "-" <b:OpExprBody3> => a.new_op2(b,
        |a, b| Op::Sub(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody3,
}

OpExprBody3: OpExprInfo = {
    <a:OpExprBody3> "*" <b:OpExprBody2> => a.new_op2(b,
        |a, b| Op::Mul(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody3> "/" <b:OpExprBody2> => a.new_op2(b,
        |a, b| Op::Div(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody3> "//" <b:OpExprBody2> => a.new_op2(b,
        |a, b| Op::Idiv(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody3> "%" <b:OpExprBody2> => a.new_op2(b,
        |a, b| Op::Mod(ResultHandle, a.into_value(meta), b.into_value(meta))),
    <a:OpExprBody3> "%%" <b:OpExprBody2> => a.new_op2(b,
        |a, b| Op::EMod(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprBody2,
}

OpExprBody2: OpExprInfo = {
    "!" <x:OpExprBody2> => x.new_op1(
        |x| Op::Equal(ResultHandle, ReprVar(FALSE_VAR.into()), x.into_value(meta))),
    "-" <x:OpExprBody2> => x.new_op1(
        |x| Op::Sub(ResultHandle, ReprVar(ZERO_VAR.into()), x.into_value(meta))),
    "~" <x:OpExprBody2> => x.new_op1(
        |x| Op::Not(ResultHandle, x.into_value(meta))),
    OpExprBody1,
}

OpExprBody1: OpExprInfo = {
    <a:OpExprAtom> "**" <b:OpExprBody1> => a.new_op2(b,
        |a, b| Op::Pow(ResultHandle, a.into_value(meta), b.into_value(meta))),
    OpExprAtom,
}

OpExprFun1TrivialValueAtom: OpExprInfo = {
    RCombValuePure<OpExprToValue<OpExprFun1TrivialValueAtom>> => <>.into(),
    MTuple<(<OpExprBody> ","?)>,
    TrivialValue => <>.into(),
}
OpExprFun1TrivialValueSelfOp: OpExprInfo = {
    OpExprValueSelfOps<OpExprToValue<OpExprFun1TrivialValueAtom>>,
    OpExprFun1TrivialValueAtom,
}
OpExprFun1TrivialValue: OpExprInfo = {
    OpExprAtomExt,
    OpExprFun1TrivialValueSelfOp,
    // NOTE 不要添加负号等, 会使优先级变得怪异如 `abs -x**2`
}
OpExprFun1<Name>: OpExprInfo = {
    Name <OpExprDExp> => OpExprType::Value(<>.into()).into(),
    Name <OpExprValueLike> => OpExprType::Value(<>).into(),
    Name <ForceSettedValue> => OpExprType::Value(<>).into(),
    Name <OpExprFun1TrivialValue>,
}
OpExprFun2<Name> = Name <MTuple<(<OpExprBody> "," <OpExprBody> ","?)>>;


OpExprCallOp: OpExprInfo = {
    OpExprFun2<"max"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::Max(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },
    OpExprFun2<"min"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::Min(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },
    OpExprFun2<"angle"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::Angle(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },
    OpExprFun2<"angleDiff"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::AngleDiff(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },
    OpExprFun2<"len"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::Len(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },
    OpExprFun2<"noise"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::Noise(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },
    OpExprFun2<"log"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::LogN(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },
    OpExprFun2<"logn"> => {
        let (a, b) = <>;
        a.new_op2(b,
            |a, b| Op::LogN(ResultHandle, a.into_value(meta), b.into_value(meta)))
    },

    OpExprFun1<"abs"> => {
        <>.new_op1(
            |a| Op::Abs(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"sign"> => {
        <>.new_op1(
            |a| Op::Sign(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"log"> => {
        <>.new_op1(
            |a| Op::Log(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"log10"> => {
        <>.new_op1(
            |a| Op::Log10(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"floor"> => {
        <>.new_op1(
            |a| Op::Floor(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"ceil"> => {
        <>.new_op1(
            |a| Op::Ceil(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"round"> => {
        <>.new_op1(
            |a| Op::Round(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"sqrt"> => {
        <>.new_op1(
            |a| Op::Sqrt(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"rand"> => {
        <>.new_op1(
            |a| Op::Rand(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"sin"> => {
        <>.new_op1(
            |a| Op::Sin(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"cos"> => {
        <>.new_op1(
            |a| Op::Cos(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"tan"> => {
        <>.new_op1(
            |a| Op::Tan(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"asin"> => {
        <>.new_op1(
            |a| Op::Asin(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"acos"> => {
        <>.new_op1(
            |a| Op::Acos(ResultHandle, a.into_value(meta)))
    },
    OpExprFun1<"atan"> => {
        <>.new_op1(
            |a| Op::Atan(ResultHandle, a.into_value(meta)))
    },
}

OpExprAtomExt: OpExprInfo = {
    MList<COArgs<OpExprBody, ",">> => <>.into_iter().flatten().collect(),
    OpExprCallOp,
    "_" => OpExprType::Ref(meta.op_expr_ref()).into(),
}
OpExprAtom: OpExprInfo = {
    Value => OpExprType::Value(<>).into(),
    OpExprValueSelfOps<Value>,
    MTuple<OpExprBody>,
    OpExprAtomExt,
}
OpExprTopSelfOps: LogicLine = {
    OrSwap<<Value>, "++"> => {
        let tmp = meta.get_tmp_var();
        Expand(vec![
            Take(tmp.clone().into(), <>).into(),
            Op::Add(tmp.clone().into(), tmp.into(), ReprVar("1".into())).into(),
        ]).into()
    },
    OrSwap<<Value>, "--"> => {
        let tmp = meta.get_tmp_var();
        Expand(vec![
            Take(tmp.clone().into(), <>).into(),
            Op::Sub(tmp.clone().into(), tmp.into(), ReprVar("1".into())).into(),
        ]).into()
    },
}
OpExprSelfOpsSuf<O>: () = O => {
    OpExprType::add_suf_selfop_handle_to_meta(meta);
};
OpExprValueSelfOps<O>: OpExprInfo = {
    "++" <O> => {
        OpExprType::Value(DExp::new(meta.unnamed_var(), vec![
            LogicLine::SetResultHandle(<>),
            Op::Add(ResultHandle, ResultHandle, ReprVar("1".into())).into(),
        ].into()).into()).into()
    },
    "--" <O> => {
        OpExprType::Value(DExp::new(meta.unnamed_var(), vec![
            LogicLine::SetResultHandle(<>),
            Op::Sub(ResultHandle, ResultHandle, ReprVar("1".into())).into(),
        ].into()).into()).into()
    },
    <O> OpExprSelfOpsSuf<"++"> <MTuple<Boxed<OpExprBodyOne>>?> => {
        OpExprType::new_suf_selfop(
            meta,
            Op::Add(ResultHandle, ResultHandle, ReprVar("1".into())),
            <>,
        ).into()
    },
    <O> OpExprSelfOpsSuf<"--"> <MTuple<Boxed<OpExprBodyOne>>?> => {
        OpExprType::new_suf_selfop(
            meta,
            Op::Sub(ResultHandle, ResultHandle, ReprVar("1".into())),
            <>,
        ).into()
    },
}

// 开始一个const, 开启了必须负责清理
ConstStart: () = () => meta.add_label_scope();
ConstStop: Vec<Var> = () => Vec::from_iter(meta.pop_label_scope());
ConstExt: () = () => meta.ext_label_scope();

BuiltinCommand: LogicLine = {
    "const" <mut values:(
        ConstStart <ConstKey> ConstExt
        "=" ConstStart <Value> <ConstStop> ","?
    )+> => {
        if values.len() == 1 {
            let (var, value, labels) = values.pop().unwrap();
            Const(var, value, labels).into()
        } else {
            let mut res = Vec::with_capacity(values.len());
            for (var, value, labels) in values {
                let r#const = Const(var, value, labels);
                res.push(r#const.into());
            }
            InlineBlock(res).into()
        }
    },

    "take" <args:MList<Args?>> <var:(<Var> "=")?> <value:Loc<Value>> => {
        Take::new(
            args.unwrap_or_default(),
            var,
            meta,
            value
        )
    },

    "take" <lines:TakeAtomList> => {
        if lines.len() == 1 {
            lines.into_iter().next().unwrap()
        } else {
            InlineBlock(lines).into()
        }
    },

    "take" "*" <results:CloseArgs<ConstKey, ",">> "="
    <l:@L> <exprs:CloseArgs<OpExprBody, ",">> <r:@R>
    =>? {
        let values = OpExprInfo::from_iter(exprs).into_values(meta);
        let len_pair = (results.len(), values.len());
        let mut lines = vec![];
        let mut values = values.into_iter();
        let mut results = results.into_iter();
        match len_pair {
            (1, 1) => {
                lines.push(Take(
                    results.next().unwrap(),
                    {values}.next().unwrap(),
                ).into());
            },
            (_, 1) => {
                let mut hresult = results.next().unwrap();
                let value = {values}.next().unwrap();

                if let ConstKey::ValueBind(ValueBind(bind, name)) = &mut hresult {
                    let tmp = meta.get_tmp_var();
                    let bind = std::mem::replace(&mut **bind, tmp.clone().into());
                    lines.push(Take(tmp.into(), bind).into());
                }

                lines.push(Take(hresult.clone(), value).into());
                for result in results {
                    let key = match hresult.clone() {
                        ConstKey::Var(v) => v.into(),
                        ConstKey::ValueBind(vb) => vb.into(),
                        ConstKey::Unused(..) => unreachable!(),
                    };
                    lines.push(Take(result, key).into());
                }
            },
            (a, b) if a == b => {
                lines.extend(results.zip(values).map(|(result, value)| {
                    Take(result, value).into()
                }))
            },
            (found, right) => {
                return Err(Error::from((
                    [l, r],
                    Errors::OpExprInvalidResult { found, right },
                )).into())
            }
        }

        Ok(if lines.len() == 1 {
            lines.pop().unwrap()
        } else {
            InlineBlock(lines).into()
        })
    },

    "setres" <Value> => LogicLine::SetResultHandle(<>),
}
TakeDestructAtom: (bool, Var, Var) = {
    <Opt<"&">> <Var> ":" <Var>,
    <c:Opt<"&">> <v:Var> => (c, v.clone(), v),
}
TakeDestruct: Vec<(bool, Var, Var)> = MBlock<(<TakeDestructAtom> ","?)*>;
TakeDestructSin: LogicLine = <de:TakeDestruct> "=" <val:Value> => {
    let key = meta.get_tmp_var().into();
    crate::make_take_destructs(meta, key, val, de)
};

TakeAtom: LogicLine = {
    "+" <key:ConstKey> => {
        Take(key, DExp::new_nores(vec![].into()).into()).into()
    },
    <key:ConstKey> <de:TakeDestruct?> "=" <val:Value> => {
        if let Some(de) = de {
            crate::make_take_destructs(meta, key, val, de)
        } else {
            Take(key, val).into()
        }
    },
    "_" "=" <val:Loc<Value>> => {
        Take::unused(meta, val).into()
    },
    "_" <de:TakeDestruct> "=" <val:Value> => {
        let key = meta.get_tmp_var().into();
        crate::make_take_destructs(meta, key, val, de)
    },
}
TakeAtomD: (LogicLine, Vec<LogicLine>) = {
    <atom:TakeAtom> ","? <tdes:(<TakeDestructSin> ","?)*> => (atom, tdes),
    <val:Loc<Value>> ","? => {
        (Take::unused(meta, val).into(), vec![])
    },
}
TakeAtomList: Vec<LogicLine> = {
    <hdes:(<TakeDestructSin> ","?)*> <lines:TakeAtomD*> => {
        hdes.into_iter()
            .chain(lines.into_iter().flat_map(|(line, tdes)| std::iter::once(line).chain(tdes)))
            .collect()
    }
}

BlockExpand: Expand = MBlock<Expand>;
Block: LogicLine = BlockExpand => <>.into();

DExp: DExp = MTuple<MakeDExpBody<Expand>>;
FEDExp: DExp = MFETuple<MakeDExpBody<Expand>>;
ValueDExp: Value = DExp => <>.into();

ClosuredValueCatch: ClosuredValueMethod = {
    <name:Var> => Take(name.clone().into(), name.into()).into(),
    <name:Var> ":" <val:Value> => Take(name.into(), val).into(),

    "&" <name:Var> => Const(name.clone().into(), name.into(), Vec::new()).into(),
    "&" <name:Var> ":" ConstStart <val:Value> <labels:ConstStop>
        => Const(name.into(), val, labels).into(),
}
ClosuredValueCatchs: (
    Vec<ClosuredValueMethod>,
    bool,
    Option<Var>,
    Option<Vec<Var>>,
) = {
    ClosuredValueCatch* Opt<"@"> (".." <Var>)?  ("|" <Label*>)?,
}
ClosuredValue: ClosuredValue = {
    MLTuple<ClosuredValueCatchs, (ConstStart <Value> <ConstStop>)> => {
        let ((catchs, catch_args, binder_to, catch_labels), (value, labels)) = <>;
        ClosuredValue::Uninit {
            catch_values: catchs,
            catch_labels: catch_labels.unwrap_or_default(),
            binder_to,
            value: value.into(),
            labels,
            catch_args,
            lazy: false,
        }
    },
    MLTuple<ClosuredValueCatchs, (ConstStart <MakeDExpBody<One<Match>>> <ConstStop>)> => {
        let (
            (catchs, catch_args, binder_to, catch_labels),
            (value, labels),
        ) = <>;
        ClosuredValue::Uninit {
            catch_values: catchs,
            catch_labels: catch_labels.unwrap_or_default(),
            binder_to,
            value: Box::new(value.into()),
            labels,
            catch_args,
            lazy: true,
        }
    },
    MLTuple<ClosuredValueCatchs, (ConstStart <MakeDExpBody<One<ConstMatch>>> <ConstStop>)> => {
        let (
            (catchs, catch_args, binder_to, catch_labels),
            (value, labels),
        ) = <>;
        ClosuredValue::Uninit {
            catch_values: catchs,
            catch_labels: catch_labels.unwrap_or_default(),
            binder_to,
            value: Box::new(value.into()),
            labels,
            catch_args,
            lazy: true,
        }
    },
}

SwitchCatchFlag: SwitchCatch = {
    "<" => SwitchCatch::Underflow,
    "!" => SwitchCatch::Misses,
    ">" => SwitchCatch::Overflow,
    MTuple<JumpCmpOnce> => SwitchCatch::UserDefine(<>),
}

ControlBlock: LogicLine = {
    "break" <bang:"!"?>
    CtrlBreakStart <lines:Or<ControlBlock, Block>> <ctrl:CtrlBreakStop>
    => {
        let mut res = Vec::with_capacity(2);
        if bang.is_none() {
            res.push(lines);
            meta.push_some_label_to(&mut res, ctrl);
        } else {
            meta.push_some_label_to(&mut res, ctrl);
            res.push(lines);
        }
        Expand(res).into()
    },
    "continue" <bang:"!"?>
    CtrlContinueStart <lines:Or<ControlBlock, Block>> <ctrl:CtrlContinueStop>
    => {
        let mut res = Vec::with_capacity(2);
        if bang.is_none() {
            meta.push_some_label_to(&mut res, ctrl);
            res.push(lines);
        } else {
            res.push(lines);
            meta.push_some_label_to(&mut res, ctrl);
        }
        Expand(res).into()
    },
}

Control: LogicLine = {
    ControlWithoutOptionalEnd,
    ControlWithOptionalEnd,
}
ControlBody: LogicLine = {
    <ControlSingle> LEnd?,
    Control,
    Block,
}
OptConstKey: Option<ConstKey> = ConstKey?;
GSwitchCase: GSwitchCase = {
    <skip_extra:Opt<"*">> <ids:Loc<Args?>> <guard:("if" <JumpCmp>)?> => GSwitchCase::Normal { skip_extra, ids: ids.map(Option::unwrap_or_default), guard },
    <skip_extra:Opt<"*">> "<" <to:OptConstKey> => GSwitchCase::Catch { skip_extra, underflow: true, missed: false, overflow: false, to },
    <skip_extra:Opt<"*">> "!" <to:OptConstKey> => GSwitchCase::Catch { skip_extra, underflow: false, missed: true, overflow: false, to },
    <skip_extra:Opt<"*">> ">" <to:OptConstKey> => GSwitchCase::Catch { skip_extra, underflow: false, missed: false, overflow: true, to },
    <skip_extra:Opt<"*">> "<" "!" <to:OptConstKey> => GSwitchCase::Catch { skip_extra, underflow: true, missed: true, overflow: false, to },
    <skip_extra:Opt<"*">> "!" ">" <to:OptConstKey> => GSwitchCase::Catch { skip_extra, underflow: false, missed: true, overflow: true, to },
    <skip_extra:Opt<"*">> "<" ">" <to:OptConstKey> => GSwitchCase::Catch { skip_extra, underflow: true, missed: false, overflow: true, to },
    <skip_extra:Opt<"*">> "<" "!" ">" <to:OptConstKey> => GSwitchCase::Catch { skip_extra, underflow: true, missed: true, overflow: true, to },
}
ControlEndLine<Line>: LogicLine = {
    "skip" <cmp:JumpCmpOnce> <body:Line> => {
        let lab = meta.get_tag();
        Expand(vec![
            Goto(lab.clone(), cmp).into(),
            body,
            LogicLine::new_label(lab, meta),
        ]).into()
    },

    "while" <cmp:JumpCmpOnce> CtrlStart <body:Line> <ctrl:CtrlStop> => {
        let (break_lab, continue_lab) = ctrl;
        let [end, head] = [meta.get_tag(), meta.get_tag()];
        let rev_cmp = cmp.clone().reverse();
        let mut res = Vec::with_capacity(7);

        res.extend([
            Goto(end.clone(), rev_cmp).into(),
            LogicLine::new_label(head.clone(), meta),
            body,
        ]);
        meta.push_some_label_to(&mut res, continue_lab);
        res.extend([
            Goto(head, cmp).into(),
            LogicLine::new_label(end, meta),
        ]);
        meta.push_some_label_to(&mut res, break_lab);

        Expand(res).into()
    },

    "gwhile" <cmp:JumpCmpOnce> CtrlStart <body:Line> <ctrl:CtrlStop> => {
        let (break_lab, continue_lab) = ctrl;
        let [to, head] = [meta.get_tag(), meta.get_tag()];
        let mut res = Vec::with_capacity(7);

        res.extend([
            Goto(to.clone(), JumpCmp::Always.into()).into(),
            LogicLine::new_label(head.clone(), meta),
            body,
            LogicLine::new_label(to, meta),
        ]);
        meta.push_some_label_to(&mut res, continue_lab);
        res.push(Goto(head, cmp).into());
        meta.push_some_label_to(&mut res, break_lab);

        Expand(res).into()
    },
}
ControlSingle: LogicLine = {
    "goto" <Label> <AlwaysJumpCmpOnce> => {
        Goto(<>).into()
    },

    "goto" "inline" <lab:Label> <cmp:AlwaysJumpCmpOnce> => {
        Goto(meta.add_defined_label(lab), cmp).into()
    },

    "break" <AlwaysJumpCmp> => {
        Goto(meta.get_break().clone(), <>).into()
    },

    "continue" <AlwaysJumpCmp> => {
        Goto(meta.get_continue().clone(), <>).into()
    },

    "do" CtrlStart <body:ControlBody> <ctrl:CtrlStop> "while" <cmp:AlwaysJumpCmpOnce> => {
        let (break_lab, continue_lab) = ctrl;
        let head = meta.get_tag();
        let mut res = Vec::with_capacity(5);

        res.extend([
            LogicLine::new_label(head.clone(), meta),
            body,
        ]);
        meta.push_some_label_to(&mut res, continue_lab);
        res.push(Goto(head, cmp).into());
        meta.push_some_label_to(&mut res, break_lab);

        Expand(res).into()
    },

    ControlEndLine<LogicLineSingle>,
}
ControlWithoutOptionalEnd: LogicLine = {
    ControlBlock,

    "inline" <Label> LEnd? => LogicLine::Label(<>),

    ControlEndLine<LogicLineNormal>,

    "skip" <body:BlockExpand> => {
        let lab = meta.get_tag();
        Expand(vec![
            Goto(lab.clone(), JumpCmp::Always.into()).into(),
            body.into(),
            LogicLine::new_label(lab, meta),
        ]).into()
    },

    "gswitch" <value:Value>
    CtrlStart
    <cases:MBlock<(
        <Expand> // append line
        <(
            "case" <GSwitchCase> ":"
            <Expand>
        )+>
    )>>
    <ctrl:CtrlStop>
    => {
        let (extra, cases) = cases;
        let (break_lab, continue_lab) = ctrl;

        let mut lines = vec![GSwitch { value, extra, cases }.into()];
        meta.push_some_label_to(&mut lines, break_lab);
        meta.push_some_label_to(&mut lines, continue_lab);
        <[_; 1]>::try_from(lines)
            .map(|[line]| line)
            .unwrap_or_else(|lines| {
                InlineBlock(lines).into()
            })
    },

    "switch" <value:Value>
    CtrlStart
    <cases:MBlock<(
        <Lines> // append line
        <( // catch 拦截
            "case"
            <SwitchCatchFlag+> // 捕获模式, 至少有一个
            // 可选的Var,
            // 会在捕获块头部使用const将该Var映射至已经求出的case跳转目标
            <Var?>
            ":"
            <Expand>
        )*>
        <( // cases
            "case"
            <Opt<"*">>
            <LiteralUInt*>
            ":"
            <Expand>
        )+>
    )>>
    <ctrl:CtrlStop>
    => {
        let (mut append, catchs, cases) = cases;
        let catchs_is_empty = catchs.is_empty();

        let mut next_case_num = 0;
        let case_num_max = cases
            .iter()
            .map(
                |(_, nums, _)| {
                    let num = nums
                        .iter()
                        .max()
                        .copied()
                        .unwrap_or(next_case_num);
                    next_case_num = num + 1;
                    num
                }
            )
            .max()
            .unwrap();

        // 用于填充填充case的行, 如果有追加在末尾的行则将其封装并替换填充
        let (mut fill_line, append) = match &append[..] {
            [] => (LogicLine::Ignore, None),
            [_] => (
                Expand(vec![append.last().unwrap().clone()]).into(),
                append.pop().unwrap().into(),
            ),
            [..] => (
                Expand(append.clone()).into(),
                Some(Expand(append).into()),
            ),
        };

        // 用于添加到头部的捕获块
        let mut catch_lines = Vec::new();
        let value_handle: Var = if catchs_is_empty {
            Var::new()
        } else { meta.get_tmp_var() };

        // 这里开始遍历捕获
        // 如果遇到了未命中捕获, 则改变fill_line为总是跳转到未命中捕获
        for (flags, name, lines) in catchs {
            let mut out_block = Vec::new();
            let skip_cmp = CmpTree::new_ands(
                flags
                    .into_iter()
                    .filter(|flag| {
                        if flag.is_misses() {
                            // 是一个未命中捕获
                            let tag = meta.get_tag();
                            out_block.push(LogicLine::new_label(tag.clone(), meta));
                            fill_line = Goto(tag, JumpCmp::Always.into()).into();
                            false // 已处理, 过滤掉
                        } else {
                            true
                        }
                    })
                    .map(|flag|
                        flag.build(value_handle.as_str().into(), case_num_max)
                    )
            ).unwrap_or(JumpCmp::Always.into());
            let skip_tag = meta.get_tag();
            out_block.insert(0, Goto(skip_tag.clone(), skip_cmp).into());
            if let Some(name) = name {
                // 如果有捕获变量则使用一个const进行映射
                // 这需要插入在头部, 也就是条件前
                // 防止`case (a) a:`时, a还没被const就进行了判断
                out_block.insert(
                    0,
                    Const::new(
                        name.into(),
                        value_handle.as_str().into()
                    ).into()
                )
            }
            out_block.push(lines.into());
            out_block.push(LogicLine::new_label(skip_tag, meta));

            catch_lines.push(Expand(out_block).into())
        }

        let mut cases_res = Vec::with_capacity(case_num_max + 1);
        let mut cases_res_isline = vec![false; case_num_max + 1];

        let mut next_ignored_num = 0;
        for (ignore_append, mut nums, mut expand) in cases {
            if let Some(append) = &append {
                if !ignore_append {
                    expand.push(append.clone())
                }
            }
            if nums.is_empty() { nums.push(next_ignored_num) }
            for num in nums {
                for _ in cases_res.len()..=num {
                    cases_res.push(LogicLine::Ignore);
                }
                cases_res[num] = expand.clone().into();
                cases_res_isline[num] = true;
                next_ignored_num = num + 1;
            }
        }
        // 将填充行填入填充case
        let mut iter = cases_res_isline.into_iter().enumerate().peekable();
        while let Some((idx, is_line)) = iter.next() {
            if is_line { continue }
            match iter.peek() {
                Some((_, true)) => cases_res[idx] = fill_line.clone(),
                _ => (),
            }
        }
        debug_assert_eq!(cases_res.len(), case_num_max + 1);
        debug_assert_eq!(cases_res.len(), cases_res.capacity());

        let (break_lab, continue_lab) = ctrl;
        if catchs_is_empty {
            // 没有捕获块
            let mut res = Vec::with_capacity(3);

            meta.push_some_label_to(&mut res, continue_lab);
            res.push(Select(value, Expand(cases_res)).into());
            meta.push_some_label_to(&mut res, break_lab);

            if res.len() == 1 {
                res.pop().unwrap()
            } else {
                Expand(res).into()
            }
        } else {
            // 有捕获块
            // 保证我们拿到了一个临时返回句柄, 而不是一个空值
            assert_ne!(&value_handle, "");
            let mut res = Vec::with_capacity(5);

            meta.push_some_label_to(&mut res, continue_lab);
            res.extend([
                // 求值
                Take(value_handle.as_str().into(), value).into(),
                // 捕获
                Expand(catch_lines).into(),
                // 主体
                Select(value_handle.into(), Expand(cases_res)).into()
            ]);
            meta.push_some_label_to(&mut res, break_lab);

            Expand(res).into()
        }
    },

    "select" <value:Value> CtrlStart <lines:BlockExpand> <ctrl:CtrlStop> => {
        let (break_lab, continue_lab) = ctrl;
        let mut res = Vec::with_capacity(3);

        meta.push_some_label_to(&mut res, continue_lab);
        res.push(Select(value, lines).into());
        meta.push_some_label_to(&mut res, break_lab);

        if res.len() == 1 {
            res.pop().unwrap()
        } else {
            Expand(res).into()
        }
    },
}

ControlWithOptionalEnd: LogicLine = {
    "if" <cmp:JumpCmpOnce> <body:Block>
        <elifs:("elif" <JumpCmpOnce> <Block>)*>
        <else_body:("else" <LogicLine>)?> =>
    {
        make_if(
            meta,
            std::iter::once((cmp, body)).chain(elifs),
            else_body,
        )
    },
}
// vim:nowrap
