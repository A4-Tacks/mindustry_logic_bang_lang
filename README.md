# 简介
这是语言`mindustry_logic_bang`的编译器, 编译目标语言是`Mindustry`游戏中的`逻辑语言`

`逻辑语言`在这是指[`Mindustry`](https://github.com/Anuken/Mindustry)
游戏中的一种名为`逻辑处理器`的建筑中编写与汇编相似的代码并将其导出的形式

# 对比
1. ### **流程控制**
   在`mindustry_logic_bang`语言中,
   可以使用`if` `elif` `else` `while` `do_while` `switch`等语句完成流程控制

   ---
   `逻辑语言`中, 跳转方式只有`jump`也就是`goto`,
   又或者设置`@counter`也就是运行时决定跳转到的位置,
   这两种方式的可读性都很差

2. ### **代码复用**
   在`mindustry_logic_bang`语言中, 我们可以使用`const-DExp`与`take`结合使用,
   它的行为可以类似于宏, 并完成零开销的代码复用.<br/>
   这门语言被设计为零开销语言, 你可以零开销的完成很多事, 而不是在编写效率与运行效率之间进行取舍.

   ---
   在`逻辑语言`中, 代码复用也不是很强, 如果手动将其封装为一个函数, 则要接受:
   1. 设置返回地址
   2. 跳转至函数头部
   3. 在函数尾部跳转回返回地址

   我们起码需要接受这整整三行的开销, 这在编写小型快速的功能时完全不能接受.
   并且更复杂的场景需要传入参数甚至返回值, 这想要做到开销就更大了.

3. ### **条件语句**
   在`mindustry_logic_bang`语言中, 我们可以使用`<=` `>=`等符号进行比较,
   并且可以使用`&&` `||` `!`符号进行组织复杂逻辑

   ---
   在`逻辑语言`中, 我们如果在游戏内自带的编辑界面, 我们可以选择`<=` `>=`等符号.<br/>
   但是如果是手动编辑`逻辑语言`, 我们将会看到`lessThanEq` `greaterThanEq`, 这编辑起来很不方便.<br/>
   并且组织复杂条件困难, 我们都知道`逻辑语言`是直接用`jump`的, 而这个`jump`是单条件的,
   我们需要手动编写短路逻辑来向指定位置各种跳转, 这太恐怖了!<br/>
   (因为密密麻麻的`jump`, 很多复杂逻辑经常被称作"盘丝洞")

4. ### **运算**
   在`mindustry_logic_bang`语言中, 我们可以使用`DExp`来将语句嵌套的塞进一行,
   可以在一行内完成多个计算.<br/>
   产生的中间变量完全编译生成名字,
   当然你可以手动指定这个变量, 在之后要使用这个中间变量的场景完成零开销.<br/>

   如果你手动编写`逻辑语言`而不是使用内置的编辑器,
   那么对于常用运算依旧要使用其序列化名称如`add` `idiv`等,
   而本语言对于这些常用的运算都分配了运算符号, 可以提升编写体验.

   ---
   在`逻辑语言`中, 每一行只能有一个`op`来进行运算, 这经常会导致很多行的运算, 非常搞心态,
   并且还要注意中间变量的复杂关系.

5. ### **学习成本**
   **注意**: 学习这门语言首先要对`逻辑语言`较为熟悉

   这门语言包含的内容并不是很多, 并且为大多数语法提供了一个示例,
   按照目录学习可以快速的掌握这门语言.

   并且在`examples/std/`中, 有着一些编写好的`const-DExp`,
   可以让你知道怎样规范的编写`const-DExp`.

6. ### **特殊语句**
   对于一些常用的特殊语句, 如`set` `print`, 是被专门处理的<br/>
   例如:

   | `bang语言`     | `逻辑语言`              |
   | -------------- | ----------------------- |
   | `set a 2;`     | `set a 2`               |
   | `a b = 1 2;`   | `set a 1`<br/>`set b 2` |
   | `print 1 2;`   | `print 1`<br/>`print 2` |
   | `op i i + 1;`  | `op add i i 1`          |
   | `op + i i 1;`  | `op add i i 1`          |

   所以不用再编写十几行`print`来打印了, 可以放到一两行中了.


# 项目构建
构建这个项目将会比较慢, 原因如下:
1. 使用`rustc`进行编译, 而它略慢, 相对`gcc` `clang`
2. 使用了大型语法分析框架`lalrpop`, 它会生成二十多万行代码, 再叠加上`rustc`编译更慢

如果你的平台是`Linux`且架构为`aarch64` `arm64`时, 不妨先试试release中作者构建的.

## 构建方法
首先安装`rust`工具链, 安装方式可以参考 <https://www.rust-lang.org/tools/install><br/>
请确保你正在使用的工具链是`stable`版本的.<br/>

接下来的构建需要更新索引并从`crates`中获取依赖, 你应该具有合适的网络环境或者配置了镜像源等

将工作目录切换至项目路径(一般就是你`git clone`下来生成的那个目录)
```shell
cargo build --release # 执行这个你可以在target/release下获得编译完成的二进制文件
cargo install --path . # 执行这个你可以在你的shell中直接使用它(假设你已经配置好cargo相关环境)
```

# 编辑器支持
为一些编辑器提供了基础的支持
- [x] `Vim` 为其配置了基础的语法高亮及折叠, 与缩进规则.<br/>
     并且如果你在使用`coc-snippets`, 或者`Ultisnips`(未测试) 的话,
     你可以享受一些配置的代码片段, 如`set` 流程控制语法 `op` `iop`等
- [x] `MT-Manager` 这是一个安卓端的文件管理器, 其中有一个文本编辑器, 可支持自定义高亮.<br/>
     为它配置了基础的语法高亮.
- [x] `VSCode` 这是一个跨平台的编辑器, 由 [westernat](https://github.com/westernat) 提供了语法支持
- [ ] `Emacs` 无

`LSP` 目前暂无实现, 也没啥必要实现, 逻辑语言这乱的, 这功能也没法用啥


# 性能
就算你塞几千行代码也基本是瞬间完成, 不用担心什么性能.

# 报错
基本没有什么报错位置, 不怎么友好, 不过基本也没啥报错, 信息也差不多够找出错误
