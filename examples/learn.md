# 引言
Bang 语言是为了在零开销的情况下, 快捷编写和封装抽象逻辑语言而诞生的语言

整体是基于逻辑语言本身的风格进行扩展的语言, 可能有些怪异与主流语言不太一样

操作重点在于编译期对代码的操作, 可以较为灵活

最为基本的可以避免到处使用行号跳转和标签跳转,
可以在构建时将`if` `while`等语句转换成`goto`, 不必自己手动编写


基本单元
===============================================================================
Bang 语言主要基于两种基本单元:

1. Value 值, 可快捷的进行传递、追溯、求值, 有许多种, 最基础的就是 Var, 下文有讲
2. Statement (语句)[^1], 作为编译时转换成逻辑行的基本单元,
   最常见的可以用多个值组成一个语句, 基本就像在逻辑语言中直接编写一样

[^1]: 这也被称作 LogicLine (逻辑行),
      但是发展到现在其作用已经不适合使用这个命名了

最基础的 Statement, 也就是上文提到的以多个值(Value)组成的, 通常首个值为 Var

```
read foo cell1 15;
```

例如上述代码是由四个值组成, 每个值都是由 Var 构成,
分别是`read` `foo` `cell1` `15`, 三个逻辑变量和一个数字.
别被逻辑变量这个名字迷惑, 逻辑中不用作变量的东西比如上面的`read`虽然表示命令,
但是和变量长得一样, 所以 Bang 对其一视同仁

> [!NOTE]
> 分号是必要的, Bang 作为一个空白符号无关语言, 空白符不会影响其语法,
所以最好有一个明确的分隔符号来分隔


简单介绍 Value
===============================================================================
Value 值也包含很多种, 首先就是最普通的 Var 可以被翻做 量、变量, 但并不仅指变量,
Var 指的是逻辑语言中一切的 logic-value 逻辑值,
也基本就是所有逻辑中可以用作字面量的部分, 如:

- 数字 `1` `1.25` `0x1f` `0x-3e`
- 字符串 `"test"`, 对于原生逻辑并不严格的反斜杠,
  Bang 的字符串中反斜杠转义会方便些, 可以使用反斜杠转义反斜杠、方括号,
  具体参见[多行字符串](./mult_line_string.mdtlbl)
- 逻辑变量 `foo` `a-b` `@copper` `true` `null` `let's`

需要注意的是, 以上的逻辑变量并不完全在 Bang 适用, 比如 `a-b` 和 `let's`,
逻辑变量过于自由, 除了某几个符号无法使用, 剩下的符号都可以拼在一起组成变量,
如果 Bang 也完全使用将会很不方便, 所以 Bang 对逻辑变量的形式做了缩减,
依照常见编程语言的形式使用 unicode-xid, 所以可以支持许多中文变量名

由一个 (xid-start 或下划线) 和若干个 xid-continue 组成一个普通的变量,
如果在前面加上`@`符号, 后面若干个 xid-continue 还允许短横线,
用于逻辑常用的一些环境变量

或者是常见的数字形式:

- 整数或浮点数: `123` `1_000_000` `1.29` `1e4` `-6`
- 进制数: `0x1f` `0b1001` `0x-2`

> [!NOTE]
> 注意, Bang 支持数字中加下划线来增加可读性,
> 不过除了这个基本全部是原样转换到逻辑语言的,
> 也就是逻辑语言本来就支持的形式`1e4`,
> 所以逻辑语言不支持的小数形式科学计数法就没进行支持了, 也就是如`1.2e3`

但是显然以上的三种并不能满足全部需求, 所以 Bang 还额外进行支持了一种万能格式

由单引号括起来的任意非空白或单引号符号, 将会组成一个 Var,
其中的双引号被转换成单引号, 因为逻辑语言本身就不允许双引号组成,
所以这种格式可以表示任意逻辑语言的变量, 例如上面举例不支持的格式:

```
set a 'a-b';
set b 'let"s';
```
编译为
```
set a a-b
set b let's
```

> [!WARNING]
> 注意不要使用一些特殊的符号, 虽然 Bang 支持但是逻辑里面有其它含义的符号,
> 例如`#`在逻辑语言里面也是注释, `;`在逻辑语言里面也用于分隔语句

---
DExp (可译做依赖表达式), 这也是一种值(Value), 意义是表示一个 Var,
但是这个 Var 的成立依赖于某些语句, 比如返回的 Var 是一个逻辑变量,
而依赖的语句给它赋值, 使这个逻辑变量成立,
可以在其开头使用一个 Var 接上冒号手动指定要返回的 Var

```
set a 1;
set b 2;
print (foo:
    foo = a+b;
);
```
编译为
```
set a 1
set b 2
op add foo a b
print foo
```

可以看到, DExp 作为一个值,
在求值时总是将其中包含的语句都编译后再将其自身的 Var 返回

*每个 Value 求值总是会返回一个 Var*

---
ResultHandle (返回句柄), 这也是一种值, 在 DExp 中使用,
代表的是当前 DExp 中要返回的那个 Var, 通常是方便对其赋值而使用的, 写法是`$`

还是以上面 DExp 的例子举例

```
set a 1;
set b 2;
print (
    $ = a+b;
);
```
和 DExp 示例中的不同, 这次我们没有手动指定返回的 Var,
所以编译器将随机生成一个 Var 来表示这个 DExp 的返回 Var,
但是这样随机生成的 Var 我们就不知道它叫什么了, 就要使用返回句柄`$`来引用它

编译为

```
set a 1
set b 2
op add __0 a b
print __0
```

可以看到, 生成了一个叫 `__0` 的变量来表示这个 DExp 的返回值,
这样可以减少大部分手动命名的疲劳

> [!NOTE]
> 尽量不要在变量中使用双下划线, 这是编译器内部约定使用的格式,
> 手动使用可能造成冲突


关于注释
===============================================================================
Bang 的注释也基于逻辑语言进行扩展,
逻辑语言使用`#`符号进行注释, 将会忽略从`#`符号开始直到行末尾的内容

Bang 的注释也如此, 但是还添加了一种新的形式, `#*`开始直到`*#`的内容将会忽略,
好处是可以跨越多行使用, 不必每行都添加注释符号,
当然为了习惯或美观还经常添加一个`*`

```
# 这是一个注释
set a 不是注释;
#* 这是一个多行注释
多行注释中
*# set b 不是注释;
set c 不是注释;
```
编译为
```
set a 不是注释
set b 不是注释
set c 不是注释
```


初探常用控制流
===============================================================================
在逻辑语言中, 控制流只有 jump 和给 `@counter`[^2] 赋值, 而在 Bang 中,
在构建时有许多方便的控制语句可以使用, 不必迷失在无尽的跳转标签中,
当然也可以使用原本逻辑的 jump, 不过在 Bang 中, 它被改名为 goto,
Bang 中的标签也从冒号结尾改成了冒号开头.

```
set a 1;
:x
set b 2;
goto :x a < b; # 因为直接跳转回了标签x, 所以执行不到下方赋值的地方
set 无法到达 3;
```
编译后
```
set a 1
set b 2
jump 1 lessThan a b
set 无法到达 3
```
可以看出, 简单的 goto 使用直接被编译为相同的 jump,
大部分之后要介绍的控制流语句都是要编译成 goto 的

[^2]: 这是逻辑语言的程序计数器, 用来指示某行执行完毕后将要执行哪行,
      可以在某行更改它以调整接下来要执行哪些代码, 灵活度很高


条件分支 (if elif else skip)
-------------------------------------------------------------------------------
`if` 是使用条件来进入某个分支的控制语句, 使用非常多, 可以很方便的划分代码关系

`elif` 是`else if`的类似物, 以前有必要现在只是写着方便

`else` 表示"否则", 如果上述条件不成立则执行`else`的代码

```
if a < b {
    print "less than";
} elif a > b {
    print "greater than";
} else {
    print "equal";
}
printflush message1;
```
编译为
```
jump 6 lessThan a b
jump 4 greaterThan a b
print "equal"
jump 7 always 0 0
print "greater than"
jump 7 always 0 0
print "less than"
printflush message1
```
从上述编译结果可以注意到, 完全符合我们的预期,
既a小于b则xxx, a大于b则xxx, 否则xxx的预期,
但是显然使用`if` `elif` `else`的形式更方便阅读

还有`skip`语句, 用法和`if`类似, 但是不会有`else`,
简单的展开为一个满足条件则跳过某段代码的`goto`


循环条件 (while gwhile do-while)
-------------------------------------------------------------------------------
循环, 通常用于满足某个条件则重复执行某段代码

- while: 满足某个条件就重复执行某段代码, 直到条件不再被满足
- gwhile: 类似 while, 但是 while 是在头部重复一个相反的条件在首次不满足时跳过,
  gwhile 的头部直接跳转到末尾条件部分, 这会在进入循环时多执行一行,
  但是大型条件等一些情况可以让代码简化, 因为只需要生成一份条件跳转而不是两份
- do-while: 类似 while, 但是总是会执行至少一遍, 然后再用条件判断是否重复执行,
  非常简单, 只是在尾部简单的生成出一个跳转到头部的 goto


```
print "while";
while i < 2 { print 1; }
print "gwhile";
gwhile i < 2 { print 1; }
print "do-while";
do { print 1; } while i < 2;
end;
```
构建[^3]为以下的类似产物
```
print "while";
{
    goto :___0 i >= 2;
    :___1
    {
        `'print'` 1;
    }
    goto :___1 i < 2;
    :___0
}
print "gwhile";
{
    goto :___2;
    :___3
    {
        `'print'` 1;
    }
    :___2
    goto :___3 i < 2;
}
print "do-while";
{
    :___4
    {
        `'print'` 1;
    }
    goto :___4 i < 2;
}
end;
```
从上述构建输出, 可以看出这三种循环的运作原理


[^3]: Bang 主要流程分为两个阶段, 构建时(Build time) 和 编译时(Compile time),
      构建时将一些简单固定的东西展开, 比如if while等, 还有收集一些标签和标签绑定等,
      编译时处理更为复杂的东西, 常量、作用域、参数系统、追溯、求值等
      通常使用`c`选项来一次性构建与编译, 或者使用`A`选项来观察构建阶段的细节


循环内控制流 (break continue)
-------------------------------------------------------------------------------
在循环内(while gwhile do-while select switch gswitch)中,
可以使用`break` `continue`语句,
直接跳出循环、跳到新一轮循环, 这可以很方便的做一些事

```
i = 0; do {
    if (op mod $ i 2;) == 0 {
        op add j j 1;
        break i > 6;
    }
    op add i i 1;
} while i < 10;
```
比如上面这份示例代码, 构建为标签形式可以直接看到其作用
```
___0:
    set i 0
___2:
    op mod __0 i 2
    jump ___1 notEqual __0 0
    op add j j 1
    jump ___0 greaterThan i 6
___1:
    op add i i 1
    jump ___2 lessThan i 10
```

> [!NOTE]
> 在select switch gswitch中, continue是跳转到整个的头部,
> 而不在循环中时, break跳转到整个代码的尾部, continue跳转到整个代码的头部,
> 而这两种基本上没有区别

也支持一种控制块, 可以在任意位置使用`break`和`continue`指向控制块头部或末尾
也可以加上叹号将含义反过来, 如果只加其中一个则不会影响另一个

```
print "begin";
break continue {
    break;
    continue;
}
print "split";
break! {
    break;
    continue;
}
print "end";
```
构建为
```
`'print'` "begin";
{
    {
        :___1
        {
            goto :___0 _;
            goto :___1 _;
        }
    }
    :___0
}
`'print'` "split";
{
    :___2
    {
        goto :___2 _;
        goto :___3 _;
    }
}
`'print'` "end";
:___3
```

整数分支结构 (select switch gswitch)
-------------------------------------------------------------------------------
这类结构通过动态的一个整数来选择第i块代码(从第0块开始), 原理依赖于`@counter`[^2]

注意不要输入非整数或者小于0的数, 或者不小于代码块数的数

`select`和`switch`会以得到优秀实践的两种形式之一展开, 区别在于两者代码量不同,
一个需要填充对齐语句块, 另一个需要构造一张跳转表, 会自动选取代码量少的形式构造

```
select i {
    print 0;
    print 1;
    print 2 2;
}
print "...";
select i {
    print 0;
    print 1 1;
    print 2 2;
}
```
比如以上代码构建为标签形式方便查看
```
    op add @counter @counter i
    jump __0 always 0 0
    jump __1 always 0 0
    jump __2 always 0 0
__0:
    print 0
__1:
    print 1
__2:
    print 2
    print 2
    print "..."
    op mul __0 i 2
    op add @counter @counter __0
    print 0
    jump __3 always 0 0
__3:
    print 1
    print 1
    print 2
    print 2
```
可以看出, 首先上面那种选择了跳转表形式生成, 下面那种选择了对齐块形式生成,
且没手动加上跳出的话, 会跳转到第i块, 然后以第i块开始将大于i的所有块都执行一遍

通常我们并不需要这样, 而是执行某一块结束后, 直接跳出整个部分,
所以可以使用`select`的进阶, `switch`

```
switch i {
    break;
case: print 0;
case: print 1;
case: print 2 2;
}
```
除了使用`case`来分隔每一块代码而不是每个 Statement 一块代码外,
还可以将每个case前的代码附加到每块`case`的最后,
我们可以用`A`选项来看到(`switch` 在构建期就会展开为 `select`)
```
{
    select i {
        {
            `'print'` 0;
            goto :___0 _;
        }
        {
            `'print'` 1;
            goto :___0 _;
        }
        {
            {
                `'print'` 2;
                `'print'` 2;
            }
            goto :___0 _;
        }
    }
    :___0
}
```
从展开后的代码可以看出`break`展开的`goto`被附加到了每个`case`最后

同时`switch`也可以不用使用空语句占位, 可以直接指定某个整数
```
switch i {
    break;
case 2:
    print 2;
case 4:
    print 4;
}
```
构建为
```
{
    select i {
        {} # ignore line
        {
            goto :___0 _;
        }
        {
            `'print'` 2;
            goto :___0 _;
        }
        {
            goto :___0 _;
        }
        {
            `'print'` 4;
            goto :___0 _;
        }
    }
    :___0
}
```
由其上也能观察出, 附加的`break`也会被附加在连续的空块最后(对于0,1, 只在1处有)

`gswitch`和`switch`没多少不同, 区别只在于其运行在编译期而不是构建期,
这可以拥有更多的高级操作, 不过它只会构建为跳转表形式而不是填充块形式,
但这样也让它可以方便的让不同的代码块指向同一份代码, 而不需要将代码块重复一份


复合条件 (CmpTree)
-------------------------------------------------------------------------------
简单单一的条件通常无法满足需求, 所以可以使用复合条件来将多个简单条件组合

复合条件通常使用三种运算符来组织

| 示例                      | 优先级      | 结合性      |
| ---                       | ---         | ---         |
| `!a < b`                  | 4           | 右结合      |
| `a && b`                  | 3           | 左结合      |
| `a || b`                  | 2           | 左结合      |
| `({print 2;} => a < b)`   | 1           | 右结合      |

也可以使用括号来手动规定比如`(a < 2 || b < 2) && c < 2`

> [!NOTE]
> `({print 2;} => a < b)` 这种为 cmp-deps, 可以在比较某个条件前展开某些代码,
> 和 DExp 有类似作用, 不过它的优先级是溢出的, 在许多地方需要加上括号使用
>
> `!` 运算并不实际存在, 它使用德摩根变换来反转内部条件, 直到反转到基本条件以结束


简单语句
===============================================================================
较为简单的语句

- noop: 逻辑中通常无法手动打出的语句, 显示为"Invalid", 解析失败的语句也会产出它
- op: 符合逻辑风格的运算语句
- print: 方便的展开为多个逻辑使用的`print`, 这样可以将内容贴在一起写很方便,
  例如: `print "foo: "foo", bar: "bar"\n";`
- 展开块 (Expand): 可以在其中包含多个语句, 通常用在循环等的后面, 例如:
  ```
  {
      print 1;
      print 2;
  }
  ```
- 标签 (Label): 用于被跳转的标签, 格式是一个冒号一个跟在后面的 Var
- 其它语句 (Other): 就是上文所提到的由多个 Value 组成的普通逻辑语句


运算和比较的逻辑风格兼容
-------------------------------------------------------------------------------
对于 CmpTree, 和 op 语句, 有做对于逻辑语言风格的兼容, 可以使用逻辑的风格来编写

例如以下的每个 skip 的条件都是相同的, 都可以经过编译

```
skip a < b print 2;
skip < a b print 2;
skip a lessThan b print 2;
skip lessThan a b print 2;
```

同样的, 以下的 op 也是产生相同的效果, 且可以正确编译
```
op add a a 1;
op a a add 1;
op + a a 1;
op a a + 1;
```

```
op floor r n 0; # 这无用的参数0不会被求值
op r floor n 0;
op floor r n;
op r floor n;
```

虽说这个风格兼容并没有什么用, 未来还可能删除, 不过或许有些人喜欢


简化运算 - 运算表达式 (op-expr)
-------------------------------------------------------------------------------
这让人们可以以传统的优先级、方便的形式不必在复杂的数学运算中编写原始的DExp形式
可以极大的降低心智负担

```
i, x = 2, abs(a-b) + sqrt(a)*2;
```
如果没有 op-expr, 我们将要编写以下构建形式, 将会非常地狱
```
{
    `set` i 2;
    op x (op $ abs (op $ a - b;);) + (op $ (op $ sqrt a;) * 2;);
}
```

同时也提供三元运算等, 详见[op-expr](./op_expr.mdtlbl)
