#**
这是switch的一种特殊语法
    可以在计算出需要跳转的case目标后, 开始跳转前, 进行捕获
    捕获后可以对其进行处理, 比如可以捕获越界的跳转, 未命中的跳转等
一共有几种捕获模式:
    ## `<`
        对跳转目标小于0时捕获
    ## `>`
        对跳转目标大于最大的case时捕获
    ## `(...)`
        当括号内条件被满足时捕获
    ## `!`
        当存在此捕获时, 填充case将会跳转至此捕获头部

捕获可重复, 捕获的判定顺序由声明顺序决定

语法:
    一个case,
    接下来是1至多个捕获模式,
    然后是可选的捕获值, 它将被const到实际要跳转到的case,
    然后是冒号
    示例: `case ! e: print e "未命中";`
*#

printflush message1;
switch (op $ x + 3;) {
    end;
case ((op $ floor e;) != e) e:
    print e " 是一个偏跳转";
    end;
case < e:
    print e " 向下越界了";
    end;
case ! e:
    print e " 未命中";
    end;
case > e:
    print e " 向上越界了";
    end;
case 1:
    print 1;
case 3:
    print 3;
}
# 以上代码首先会对switch后面的值进行take求值, 因为我们编写了捕获
# 然后按声明顺序判断每一个捕获
# 如果未命中捕获存在则永远跳过它, 然后填充case被改为跳进未命中捕获
# 在每一个捕获中如果使用了捕获值例如`case ! x`这里将捕获值捕获到x
#   那么在捕获头部会进行一个`const x = 之前take的句柄;`
# 然后是捕获中的语句
#
# 接下来再看以上代码, 我们可以发现, 当未命中捕获后还会进行一次上越界捕获判定
#   这在一些情况下很有用,
#       例如我们在未命中捕获中可以中途改变需要跳转到的目标再进行跳转
#   这在其它捕获中也适用, 我们可以捕获后不进行终止等操作 而是直接修改跳转目标
#       当然, 这要求你输入的值并不是一个字面量, 否则可能出现`op 1 1 + x`这样的
