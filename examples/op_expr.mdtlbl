#**
* 这是在0.11.0版本添加的表达式系统, 旨在更加干练的编写复杂运算
* 可以有限的以我们比较常见的表达式形式使用op来进行运算
* 这个语法可以看成在对sets左值为单个时的行为扩展
* 在sets左值为单个Value时, 右值将成为一个op-expr
*
* 以下为各种运算符的优先级与结合性:
* | 符号       | 实际运算(op) | 优先级 | 结合性 |
* | ---------- | ------------ | ------ | ------ |
* | `a ** b`   | `a ** b`     | -1     | RL     |
* | `! x`      | `x != false` | -2     | R      |
* | `- x`      | `0 - x`      | -2     | R      |
* | `~ x`      | `~ x`        | -2     | R      |
* | `a * b`    | `a * b`      | -3     | LR     |
* | `a / b`    | `a / b`      | -3     | LR     |
* | `a % b`    | `a % b`      | -3     | LR     |
* | `a // b`   | `a // b`     | -3     | LR     |
* | `a + b`    | `a + b`      | -4     | LR     |
* | `a - b`    | `a - b`      | -4     | LR     |
* | `a << b`   | `a << b`     | -5     | LR     |
* | `a >> b`   | `a >> b`     | -5     | LR     |
* | `a & b`    | `a & b`      | -6     | LR     |
* | `a ^ b`    | `a ^ b`      | -7     | LR     |
* | `a | b`    | `a | b`      | -8     | LR     |
* | `a < b`    | `a < b`      | -9     | -      |
* | `a > b`    | `a > b`      | -9     | -      |
* | `a <= b`   | `a <= b`     | -9     | -      |
* | `a >= b`   | `a >= b`     | -9     | -      |
* | `a == b`   | `a == b`     | -10    | -      |
* | `a != b`   | `a != b`     | -10    | -      |
* | `a === b`  | `a === b`    | -10    | -      |
* | `a !== b`  | `a !== b`    | -10    | -      |
* | `a && b`   | `a && b`     | -11    | LR     |
* | `a || b`   | `a + b`      | -12    | LR     |
* | `if c?a:b` | ...          | -13    | LR     |
*
* 结合性的`LR`指左结合 比如`a+b+c`结合为`(a+b)+c`
* 而结合性为`-`指不发生结合, 将需要添加括号
*
* 以上表格外, 还有一元与二元函数(其实就是op)
* 它们的优先级与括号平级,
* 二元函数有: `max` `min` `angle` `len` `noise`,
* 一元函数的部分列举有: `log` `rand` ...,
*
* 具体参考op中没有符号的运算
*
* 对于三元表达式, 也就是`if c?a:b`,
* 它是低优先级的, 所以参与高优先级运算时需要括号括起.
* 就算是`1+if x != y ? x : y`这样的, 也需要写成`1+(if x != y ? x : y)`
* 想要取消这个设计的方案有几个但都极其复杂, 所以就如现在这样
*
* 在0.14.21版本中, 添加了一个语法糖, 可以用 `(?x: a+b)` 来表示 `(x: $=a+b;)`
*#

x = 1 + 2 * 3;
y = (1 + 2) * 3;
z = min(a+b, c-d);
#* A >>>
op 'x' '1' + (op $ '2' * '3';);
op 'y' (op $ '1' + '2';) * '3';
op 'z' min (op $ 'a' + 'b';) (op $ 'c' - 'd';);
*#
# 我们可以看出, 优先级生效了, 并且运算被正常解析为DExp树了
# 并且我们并没有遇到最后要经历一遭set的问题, 因为解析时有一个安全标记
# 这个标记将使我们可以正确的将op与set合并.
#
# 当然, 需要注意的是,
# 虽然运算成员是Value, 但依旧不推荐使用`$`符号(返回句柄替换符)
# 因为这并没有什么意义, 且如果在最外层, 那么因为最顶层op与set的合并,
# 这个句柄将会指向set的更外层的DExp.


# 在0.11.2版本起, 我们可以像sets一样, 同时进行多个
a, b, c = x, -y, z+2*3;
#* A >>>
{
    `'set'` 'a' 'x';
    op 'b' `'0'` - 'y';
    op 'c' 'z' + (op $ '2' * '3';);
}
*#
# 可以看到, 就像sets一样, 只不过使用逗号分隔了.
# 对于多个简易运算, 我们不用写在多行或者使用额外一个set来换取写在一行中了
# 当然, 运算之外的例如sensor还是不能这么做,
# 因为op-expr的内联set目前仅为它自己的op服务
#
# 起码我们在数学运算方面的舒适度上来了不是吗


# 三元表达式可以在分支运算赋值上进行简化
x = if a < b ? 2 + 3 : 4;
#* A >>>
{
    take '___0' = 'x';
    goto :'___0' 'a' < 'b';
    `'set'` '___0' '4';
    goto :'___1' _;
    :'___0'
    op '___0' '2' + '3';
    :'___1'
}
*#

x = if a < b ? if c < d ? c : d : if e < f ? e : f;
#* A >>>
{
    take '___2' = 'x';
    goto :'___4' 'a' < 'b';
    {
        take '___1' = '___2';
        goto :'___2' 'e' < 'f';
        `'set'` '___1' 'f';
        goto :'___3' _;
        :'___2'
        `'set'` '___1' 'e';
        :'___3'
    }
    goto :'___5' _;
    :'___4'
    {
        take '___0' = '___2';
        goto :'___0' 'c' < 'd';
        `'set'` '___0' 'd';
        goto :'___1' _;
        :'___0'
        `'set'` '___0' 'c';
        :'___1'
    }
    :'___5'
}
*#

x = 1 + (if y ? y : z);
#* A >>>
op 'x' '1' + (
    take '___0' = $;
    goto :'___0' 'y' != `'false'`;
    `'set'` '___0' 'z';
    goto :'___1' _;
    :'___0'
    `'set'` '___0' 'y';
    :'___1'
);
*#
# 由于前面解释过的原因, 你需要添加括号


# 这是0.12.7版本添加的语法, 可以将一个值一次赋给多个接收者
# 方法是使用首次赋值的值来为接下来赋值
#
# 需要注意的是, 求值顺序是:
# 第一个接收者 -> 值 -> 第二个接收者 -> ... -> 第N个接收者

a, b, c = 1 + 2 * 3;
#* A >>>
{
    take ___0 = a;
    op ___0 1 + (op $ 2 * 3;);
    `'set'` b ___0;
    `'set'` c ___0;
}
*#


#**
* 在0.14.17版本, 可以对常见的运算使用自运算格式, 这会简化一些代码
*#
x += n*2;
