#**
* 这是在0.11.0版本添加的表达式系统, 旨在更加干练的编写复杂运算
* 可以有限的以我们比较常见的表达式形式使用op来进行运算
* 这个语法可以看成在对sets左值为单个时的行为扩展
* 在sets左值为单个Value时, 右值将成为一个op-expr
*
* 以下为各种运算符的优先级与结合性:
* | 符号      | 实际运算(op) | 优先级 | 结合性 |
* | --------- | ------------ | ------ | ------ |
* | `a ** b`  | `a ** b`     | -1     | RL     |
* | `! x`     | `x != false` | -2     | R      |
* | `- x`     | `0 - x`      | -2     | R      |
* | `~ x`     | `~ x`        | -2     | R      |
* | `a * b`   | `a * b`      | -3     | LR     |
* | `a / b`   | `a / b`      | -3     | LR     |
* | `a % b`   | `a % b`      | -3     | LR     |
* | `a // b`  | `a // b`     | -3     | LR     |
* | `a + b`   | `a + b`      | -4     | LR     |
* | `a - b`   | `a - b`      | -4     | LR     |
* | `a << b`  | `a << b`     | -5     | LR     |
* | `a >> b`  | `a >> b`     | -5     | LR     |
* | `a & b`   | `a & b`      | -6     | LR     |
* | `a ^ b`   | `a ^ b`      | -7     | LR     |
* | `a | b`   | `a | b`      | -8     | LR     |
* | `a == b`  | `a == b`     | -9     | LR     |
* | `a != b`  | `a != b`     | -9     | LR     |
* | `a < b`   | `a < b`      | -9     | LR     |
* | `a > b`   | `a > b`      | -9     | LR     |
* | `a <= b`  | `a <= b`     | -9     | LR     |
* | `a >= b`  | `a >= b`     | -9     | LR     |
* | `a === b` | `a === b`    | -9     | LR     |
* | `a !== b` | `a !== b`    | -9     | LR     |
* | `a && b`  | `a && b`     | -10    | LR     |
* | `a || b`  | `a + b`      | -11    | LR     |
*
* 以上表格外, 还有一元与二元函数(其实就是op)
* 它们的优先级与括号平级,
* 二元函数有: `max` `min` `angle` `len` `noise`,
* 一元函数的部分列举有: `log` `rand` ...,
*
* 具体参考op中没有符号的运算
*#

x = 1 + 2 * 3;
y = (1 + 2) * 3;
z = min(a+b, c-d);
#* A >>>
op 'x' '1' + (op $ '2' * '3';);
op 'y' (op $ '1' + '2';) * '3';
op 'z' min (op $ 'a' + 'b';) (op $ 'c' - 'd';);
*#
# 我们可以看出, 优先级生效了, 并且运算被正常解析为DExp树了
# 并且我们并没有遇到最后要经历一遭set的问题, 因为解析时有一个安全标记
# 这个标记将使我们可以正确的将op与set合并.
#
# 当然, 需要注意的是,
# 虽然运算成员是Value, 但依旧不推荐使用`$`符号(返回句柄替换符)
# 因为这并没有什么意义, 且如果在最外层, 那么因为最顶层op与set的合并,
# 这个句柄将会指向set的更外层的DExp.


# 在0.11.2版本起, 我们可以像sets一样, 同时进行多个
a, b, c = x, -y, z+2*3;
#* A >>>
{
    `'set'` 'a' 'x';
    op 'b' `'0'` - 'y';
    op 'c' 'z' + (op $ '2' * '3';);
}
*#
# 可以看到, 就像sets一样, 只不过使用逗号分隔了.
# 对于多个简易运算, 我们不用写在多行或者使用额外一个set来换取写在一行中了
# 当然, 运算之外的例如sensor还是不能这么做,
# 因为op-expr的内联set目前仅为它自己的op服务
#
# 起码我们在数学运算方面的舒适度上来了不是吗
