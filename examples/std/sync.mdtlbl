#**
* 这是关于同步相关 (多逻辑协同) 的一些工具
* 目前提供帧互斥锁、皮特森互斥锁
*
* 主要可用方法:
*   Init: 初始化内存中锁状态
*   Lock: 加锁, 传入 id
*   Free: 解锁, 传入 id
*   With: 加锁、执行指定代码、解锁, 传入 id 和需要运行的代码
*#

Builtin.BindSep! '.';
Builtin.MissesMatch! 1;

const MakeTickLocker = (match @ => $Locker Mem Addr {
    #**
    * 帧互斥锁, 又称刻互斥锁,
    * 利用每帧头部更新 @tick 环境变量的特性对多逻辑进行全局同步,
    * 同步成功后抢锁可以避免坏读写, 实现稳定抢锁
    *
    * 要求不同加锁者必须各自提供不同的 id
    * 要求未加锁时内存地址处的值被初始化为 -1, 可以通过调用 Init 实现
    *
    * 优点是可以任意核加锁、对 id 只有不重复的要求, 并且实现简单
    * 缺点是单核性能被锁死, 每次尝试加锁通常要消耗一个完整的 @ipt,
    *   当使用超核时 ipt 已经达到了 25, 而使用世处 ipt 将可以达到 1000
    *   所以该锁在最快的世处进行加锁时, 通常需要执行一千条语句, 这很影响速度
    *#
    const $.Mem = Mem;
    const $.Addr = Addr;
    const $.Init = (match @ => { write -1 ...Mem ...Addr });
    const $.TickSync = (match @ => {
        ...tick = @tick;
        do { } while @tick == ...tick;
    });
    const $.Lock = (match @ => Id {
        do {
            do { ...TickSync! } while (read $ ...Mem ...Addr) != -1;
            write Id ...Mem ...Addr;
        } while (read $ ...Mem ...Addr) != Id;
    });
    const $.Free = (match @ => @ { write -1 ...Mem ...Addr });
    const $.With = (const match @ => *_Id_ _F_ {
        ...Lock! _Id_;
        setres _F_[];
        ...Free! _Id_;
    });
});
const MakePetersonLocker = (match @ => $Locker Mem Addr {
    #**
    * 皮特森互斥锁, 用于在两个逻辑间使用互斥锁, 不能超过两个逻辑
    * 是经典的条件关系互斥,
    * 由于逻辑的内存模型很简单, 没有流水线、缓存一致、部分写入等问题, 所以可以很好的应用
    *
    * 要求 id 的值必须为 0 或者 1, 并且需要三个内存槽位 (Addr, Addr+1, Addr+2)
    *
    * 优点是条件关系互斥并不依赖同步, 即利用 @tick 更新时机全局刻同步
    *   所以在 ipt 很高的时候 (例如世处调速至 1000 ),
    *   该锁的速度也会随之提升, 而不是像刻同步锁那样消耗一帧来同步
    * 缺点是 id 要求很严格 (0或1), 且最多只能在两个逻辑间使用
    *#
    const $.Mem = Mem;
    const $.Addr = Addr;
    take* $.Flag = Addr + 1;
    const $.Init = (match @ => {
        take {Addr Flag} = ..;
        write false ...Mem Addr;
        write false ...Mem Flag;
        write false ...Mem (*Flag+1);
    });
    const $.Lock = (match @ => Id {
        take {Addr Flag free_addr} = ..;
        take*OtherId = !Id;
        take*Self, Other = (free_addr:=Flag+Id), Flag+OtherId;
        write true ...Mem Self;
        write OtherId ...Mem Addr;
        do { } while (read $ ...Mem Other) && OtherId == (read $ ...Mem Addr);
    });
    const $.Free = (match @ => Id {
        write false ...Mem ...free_addr;
    });
    const $.With = (const match @ => *_Id_ _F_ {
        ...Lock! _Id_;
        setres _F_[];
        ...Free! _Id_;
    });
});
const MakeBakeryAlgorithmLocker = (match @ => $Locker Mem Addr N {
    #**
    * 烘培店互斥锁, 类似皮特森互斥锁, 但是支持多个逻辑间使用
    *
    * 要求 id 的值必须为 0 1 ... N-1 (N为逻辑块数量)
    *
    * 优点是在皮特森互斥锁的基础上, 可支持更多逻辑间使用互斥锁
    * 缺点是这个算法很复杂, 需要执行非常多的语句, 并且逻辑块越多需要执行的也越多
    *   并且需要的内存槽位也随着逻辑块数量增加而增加
    *#
    const $.Mem = Mem;
    const $.Addr = Addr;
    const $.N = N;
    take* $.Number = Addr;
    take* $.Choosing = Addr + N;
    const $.Init = (match @ => {
        take {Addr N} = ..;
        take*End = Addr + N*2;
        +I = Addr; do {
            write 0 ...Mem I;
        } while ++I < End;
    });
    const $.Lock = (match @ => Id {
        take {Number Choosing N NumberId:free_addr} = ..;
        take+ChoosingId+I;
        write true ...Mem (?ChoosingId:Choosing+Id);
        take*NumberEnd = Number+N;
        +Max = 0;
        I = Number; do { Max max= (read $ ...Mem I) } while ++I < NumberEnd;
        write (*Max+1) ...Mem (?NumberId:Number+Id);
        write false ...Mem ChoosingId;
        I = Number; do {
            take+INum+IdNum;
            +ChoosingI = I + N;
            do { } while (read $ ...Mem ChoosingI);
            do { } while (INum:read $ ...Mem I) && (
                INum < (IdNum:read $ ...Mem NumberId)
                || IdNum == INum && I < NumberId
            );
        } while ++I < NumberEnd;
    });
    const $.Free = (match @ => Id {
        write false ...Mem ...free_addr;
    });
    const $.With = (const match @ => *_Id_ _F_ {
        ...Lock! _Id_;
        setres _F_[];
        ...Free! _Id_;
    });
});

#MakeTickLocker! locker cell1 1;
#MakePetersonLocker! locker cell1 1;
MakeBakeryAlgorithmLocker! locker cell1 1 4;
locker.Init!;

id = @thisx // 3 % 4;
break (sensor $ switch1 @enabled;);
wait (*rand(1)+0.5);
do { } while (*rand 1) < 0.7;

looping = 0; do {
    locker.With! id (
        do { } while (*rand 1) < 0.7;
        read n cell1 0;
        write (*++n) cell1 0;
    );
    do { } while (*rand 1) < 0.4;
} while ++looping < 200;

do {} while !(sensor $ switch1 @enabled;);
